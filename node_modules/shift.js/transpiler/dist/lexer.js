module.exports = {
  deepEqual: function(a,b) {
    if (a === b) {
      return true;
    }
    if (a == null || typeof a != "object" || b == null || typeof b != "object") {
      return false;
    }
    var propsInA = 0, propsInB = 0;
    for (var prop in a) {
      propsInA += 1;
    }
    for (prop in b) {
      propsInB += 1;
      if (!(prop in a) || !(module.exports.deepEqual(a[prop],b[prop]))) {
        return false;
      }
    }
    return propsInA === propsInB;
  },
  diff: function(a,b) {
    var results = [];
    for (var i = 0; i < Math.max(a.length,b.length); i++) {
      if (!module.exports.deepEqual(a[i],b[i])) {
        results.push({'index': i, 'actual output': a[i], 'expected answer': b[i]});
      }
    }
    return results;
  }
};

var lexerFunctions = require("./lexerFunctions");

module.exports = function(code) {

  var STATE = {
    i: 0,
    tokens: [],
    currentTokenLength: 0,
    chunk: '',
    currCol: undefined,
    prevCol: undefined,
    nextCol: undefined,
    nextNextCol: undefined,
    VARIABLE_NAMES: {},
    FUNCTION_NAMES: {},
    CLASS_NAMES: {},
    STRUCT_NAMES: {},
    TUPLE_ELEMENT_NAMES: {},
    emptyLine: true,
    insideString: false,
    insideNumber: false,
    insideCollection: [],
    insideFunction: [],
    insideClass: [],
    insideStruct: [],
    stringInterpolation: {status: false, counter: 0, nestedInvocation: false},
    substringLookup: false,
    insideComment: {multi: false, single: false},
    insideTuple: {status: false, startIndex: undefined},
    insideInvocation: [],
    insideInitialization: [],
    lastToken: undefined,
    lastCollection: undefined,
    lastFunction: undefined,
    variableArrows: [],
    advance: function(positions) {
      this.i += positions;
    },
    clearChunk: function() {
      this.chunk = '';
    },
    advanceAndClear: function(positions) {
      this.i += positions;
      this.chunk = '';
    }
  }

  while (code[STATE.i] !== undefined) {
    //debugger;
    STATE.chunk += code[STATE.i];
    STATE.currCol = code[STATE.i];
    STATE.prevCol = code[STATE.i - 1];
    STATE.nextCol = code[STATE.i + 1];
    STATE.nextNextCol = code[STATE.i + 2];
    STATE.lastToken = STATE.tokens[STATE.tokens.length - 1];
    STATE.lastCollection = STATE.insideCollection[STATE.insideCollection.length - 1];
    STATE.lastFunction = STATE.insideFunction[STATE.insideFunction.length - 1];

    // console.log(STATE.chunk);
    // console.log(STATE.currCol);
    // console.log(STATE.nextCol);
    // console.log(STATE.tokens);
    // console.log(STATE.emptyLine);
    // console.log(STATE.insideInvocation[STATE.insideInvocation.length - 1]);
    
    // if (STATE.tokens.length !== STATE.currentTokenLength) {
    //  if (STATE.insideInvocation.length) {
    //    console.log(STATE.insideInvocation[STATE.insideInvocation.length - 1].name);
    //    console.log(STATE.insideInvocation[STATE.insideInvocation.length - 1].status);
    //    console.log(STATE.insideInvocation[STATE.insideInvocation.length - 1].parens);
    //  }
    //  STATE.currentTokenLength = STATE.tokens.length;
  //   // }

    // if (STATE.tokens.length !== STATE.currentTokenLengt //h) {
    //  if (STATE.insideFunction.l //ength) {
    //    console.log(STATE.tokens.length, STATE.insideFunction[STATE.insideFunction.length - 1].returnArro // //ws);
    //  }
    //  STATE.currentTokenLength = STATE.tokens //.length;
    // }

    // handles new lines
    if (lexerFunctions.handleNewLine(STATE)) {
      STATE.advanceAndClear(1);
      continue
    }

    // handles comments
    if (lexerFunctions.checkForCommentStart(STATE)) {
      STATE.advanceAndClear(2);
      continue;
    }
    if (lexerFunctions.handleComment(STATE)) {
      continue;
    }
    if (lexerFunctions.checkIfInsideComment(STATE)) {
      STATE.advance(1);
      continue;
    }

    // ignores chunks that are solely whitespace
    if (lexerFunctions.checkForWhitespace(STATE.chunk)) {
      STATE.advanceAndClear(1);
      continue;
    }

    // tracks whether inside a string
    if (STATE.currCol === '"' && STATE.insideString) {
      STATE.insideString = false;
    } else if (STATE.currCol === '"') {
      STATE.insideString = true;
    }

    // handles numbers
    if (lexerFunctions.handleNumber(STATE) === true) {
      STATE.advanceAndClear(1);
      continue;
    } else if (lexerFunctions.handleNumber(STATE) === "skip"){
      lexerFunctions.handleEndOfFile(STATE.nextCol, STATE.tokens);
      STATE.advance(2);
      continue;
    }

    // handles ranges
    if (lexerFunctions.handleRange(STATE)) {
      STATE.advanceAndClear(3);
      continue;
    }

    // handles string interpolation
    if (lexerFunctions.checkForStringInterpolationStart(STATE)) {
      STATE.advanceAndClear(3);
      continue;
    }
    if(lexerFunctions.checkForStringInterpolationEnd(STATE)) {
      STATE.advanceAndClear(1);
      STATE.chunk = '"';
      continue;
    }

    // Tokenizing return arrow
    if (STATE.currCol === "-" && STATE.nextCol === ">") {
      lexerFunctions.checkFor(STATE, 'FUNCTION_DECLARATION', "->", STATE.tokens);
      if (STATE.insideFunction.length) {
        STATE.insideFunction[STATE.insideFunction.length - 1].returnArrows.push(STATE.tokens.length - 1);
      } else {
        STATE.variableArrows.push(STATE.tokens.length - 1);
        lexerFunctions.rewriteVariableParensHistory(STATE);
      }
      STATE.advanceAndClear(2);
      continue;
    }

    // adding the recently declared function to the FUNCTION_NAMES property, this may not work in all cases by adding incorrectly identified functions
    if (STATE.insideFunction.length && STATE.lastFunction.insideParams === true && STATE.chunk === '(') {
      // lexerFunctions.checkFor(STATE, 'FUNCTION_DECLARATION', STATE.chunk, STATE.tokens);
        var len = STATE.tokens.length - 1;
        while (STATE.tokens[len].type !== 'IDENTIFIER') {
          len--;
        }
        STATE.FUNCTION_NAMES[STATE.tokens[len].value] = true;
    }

    // Handles Function Invocations starting and ending
    if (lexerFunctions.handleFunctionInvocationStart(STATE)) {
      continue;
    }

    if (lexerFunctions.handleFunctionInvocationEnd(STATE)) {
      continue;
    }



    // tuple handling
    if (lexerFunctions.checkForTupleStart(STATE)) {
      STATE.advanceAndClear(1);
      continue;
    }
    if (STATE.insideTuple.status && lexerFunctions.handleTuple(STATE)) {
      STATE.advanceAndClear(1);
      continue;
    }
    if (lexerFunctions.checkForTupleEnd(STATE)) {
      STATE.advanceAndClear(1);
      lexerFunctions.handleEndOfFile(STATE.nextCol, STATE.tokens);
      continue;
    }

    // handling the ()'s inside of the function invocation
    if (lexerFunctions.handleFunctionInvocationInside(STATE)) {
      continue;
    }

    //handling functions declarations
    if (lexerFunctions.handleFunctionDeclarationStart(STATE)) {
      continue;
    }

    if (lexerFunctions.handleFunctionDeclarationInside(STATE)) {
      continue;
    }

    if (lexerFunctions.handleFunctionDeclarationEnd(STATE)) {
      continue;
    }

    // collection initializer handling
    if (STATE.tokens.length && STATE.currCol === '(' &&
      (STATE.lastToken.type === 'ARRAY_END' || STATE.lastToken.type === 'DICTIONARY_END')) {
      lexerFunctions.checkFor(STATE, 'FUNCTION_INVOCATION', STATE.currCol, STATE.tokens);
      var tmp = {};
      tmp.name = STATE.lastToken.value;
      tmp.status = true;
      tmp.parens = 0;
      STATE.insideInvocation.push(tmp);
      STATE.advanceAndClear(1);
      continue;
    }

    // handles colons functioning as inheritance operators
    if (STATE.tokens.length > 2 && STATE.tokens[STATE.tokens.length - 2].value === ':' &&
      STATE.CLASS_NAMES[STATE.lastToken.value] && STATE.CLASS_NAMES[STATE.tokens[STATE.tokens.length - 3].value]) {
      STATE.tokens[STATE.tokens.length - 2].type = 'INHERITANCE_OPERATOR';
    }

    // handles classes and structs
    if (lexerFunctions.handleClassOrStruct(STATE)) {
      STATE.advanceAndClear(1);
      continue;
    }

    // handles parentheses inside class and struct initialization
    if (STATE.chunk === '(' && STATE.insideInitialization.length &&
      STATE.insideInitialization[STATE.insideInitialization.length - 1].parens >= 1) {
      STATE.insideInitialization[STATE.insideInitialization.length - 1].parens++;
    }
    if (STATE.chunk === ')' && STATE.insideInitialization.length) {
      STATE.insideInitialization[STATE.insideInitialization.length - 1].parens--;
    }

    // handles property access and method calls via dot notation
    if (STATE.currCol === '.' && !lexerFunctions.checkForWhitespace(STATE.prevCol) &&
      !lexerFunctions.checkForWhitespace(STATE.nextCol) && (
        STATE.lastToken.type === 'IDENTIFIER' || STATE.lastToken.value === 'self' ||
        STATE.lastToken.type === 'TYPE_PROPERTY')) {
      lexerFunctions.makeToken(undefined, STATE.chunk, STATE.tokens, 'DOT_SYNTAX', '.');
      STATE.advanceAndClear(1);
      continue;
    }
    // main evaluation block
    if (!STATE.insideString && !STATE.insideNumber &&
      lexerFunctions.checkForEvaluationPoint(STATE)) {
      if (STATE.lastToken && STATE.lastToken.type === 'DOT_SYNTAX' && STATE.TUPLE_ELEMENT_NAMES[STATE.chunk]) {
        lexerFunctions.makeToken(undefined, undefined, STATE.tokens, 'TUPLE_ELEMENT_NAME', STATE.chunk);
      } else if (STATE.insideCollection.length && STATE.lastCollection.type === undefined &&
        lexerFunctions.checkFor(STATE, 'PUNCTUATION', STATE.chunk, STATE.tokens)) {
        lexerFunctions.determineCollectionType(STATE);
      } else if (STATE.insideCollection.length && STATE.currCol === ']' && !STATE.substringLookup) {
        lexerFunctions.checkFor(STATE, 'COLLECTION', STATE.chunk, STATE.tokens, function() {
          STATE.tokens[STATE.tokens.length - 1].type = STATE.lastCollection.type || 'ARRAY_END';
          STATE.insideCollection.pop();
        });
      } else if (STATE.tokens.length && STATE.lastToken.type !== 'IDENTIFIER' &&
        STATE.lastToken.type !== 'SUBSCRIPT_LOOKUP_END' && STATE.currCol === '[') {
        lexerFunctions.checkFor(STATE, 'COLLECTION', STATE.chunk, STATE.tokens, function(){
          STATE.insideCollection.push({type: undefined, location: STATE.tokens.length-1});})
      } else {
        lexerFunctions.checkFor(STATE, 'KEYWORD', STATE.chunk, STATE.tokens) ||
        lexerFunctions.checkFor(STATE, 'NATIVE_METHOD', STATE.chunk, STATE.tokens) ||
        lexerFunctions.checkFor(STATE, 'METHOD_ARGUMENT_NAME', STATE.chunk, STATE.tokens) ||
        lexerFunctions.checkFor(STATE, 'TYPE_PROPERTY', STATE.chunk, STATE.tokens) ||
        lexerFunctions.checkFor(STATE, 'TYPE', STATE.chunk, STATE.tokens) ||
        lexerFunctions.checkFor(STATE, 'PUNCTUATION', STATE.chunk, STATE.tokens) ||
        lexerFunctions.checkFor(STATE, 'SUBSCRIPT_LOOKUP', STATE.chunk, STATE.tokens, function() {
          STATE.substringLookup = !STATE.substringLookup;
        }) ||
        lexerFunctions.checkFor(STATE, 'OPERATOR', STATE.chunk, STATE.tokens) ||
        lexerFunctions.checkFor(STATE, 'TERMINATOR', STATE.chunk, STATE.tokens) ||
        lexerFunctions.checkForIdentifier(STATE) ||
        lexerFunctions.checkForLiteral(STATE.chunk, STATE.tokens);
      }

      STATE.clearChunk();

      // special evaluation point handling
      if (lexerFunctions.checkForWhitespace(STATE.nextCol)) {
        STATE.advance(1);
      }
      lexerFunctions.handleEndOfFile(STATE.nextCol, STATE.tokens);

    }
    STATE.advance(1);
    // console.log(STATE.tokens);
  }

  if (STATE.tokens[STATE.tokens.length - 1].value === '\\n') {
    lexerFunctions.makeToken(undefined, undefined, STATE.tokens, 'TERMINATOR', 'EOF');
  }
  // console.log(STATE.tokens);
  return STATE.tokens;

};

var lexicalTypes = require("./lexicalTypes");

var NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;
var WHITESPACE = /^[^\n\S]+/;

module.exports = {

  // helper function to check for whitespace
  checkForWhitespace: function(col) {
    // return col === ' ';
    return WHITESPACE.test(col);
  },
  
  // default check for point at which to evaluate chunk
  checkForEvaluationPoint: function(STATE) {
    if (
      module.exports.checkForWhitespace(STATE.currCol) ||
      module.exports.checkForWhitespace(STATE.nextCol) ||
      module.exports.checkFor(STATE, 'PUNCTUATION', STATE.currCol) ||
      module.exports.checkFor(STATE, 'PUNCTUATION', STATE.nextCol) ||
      module.exports.checkFor(STATE, 'OPERATOR', STATE.nextCol) ||
      module.exports.checkFor(STATE, 'OPERATOR', STATE.currCol) ||
      STATE.nextCol === '"' || STATE.nextCol === ']' || STATE.currCol === '[' ||
      STATE.currCol === ']' || STATE.nextCol === '[' || STATE.nextCol === '\n' ||
      STATE.nextCol === undefined

    ) {

      return true;

    }
    return false;
  },

  // helper function to handle function invocation
  handleFunctionInvocationStart: function(STATE) {
    if (STATE.chunk === '(' && ((STATE.FUNCTION_NAMES[STATE.lastToken.value] &&
      STATE.tokens[STATE.tokens.length - 2].value !== 'func') || STATE.lastToken.type === 'NATIVE_METHOD' || STATE.lastToken.type === 'TYPE_STRING' ||
      STATE.lastToken.type === 'TYPE_NUMBER')) {
      module.exports.checkFor(STATE, 'FUNCTION_INVOCATION', STATE.chunk, STATE.tokens);
      var tmp = {};
      tmp.name = STATE.lastToken.value;
      tmp.status = true;
      tmp.parens = 0;
      STATE.insideInvocation.push(tmp);
      if (STATE.stringInterpolation.status) {
        STATE.stringInterpolation.nestedInvocation = true;
      }
      STATE.advanceAndClear(1);
      return true;
    }
    return false;
  },

  handleFunctionInvocationEnd: function(STATE) {
    if (STATE.insideInvocation.length &&
        (STATE.insideInvocation[STATE.insideInvocation.length - 1]).status &&
        STATE.chunk === ')' &&
        (STATE.insideInvocation[STATE.insideInvocation.length - 1]).parens === 0 && !STATE.insideTuple.status) {
      module.exports.checkFor(STATE, 'FUNCTION_INVOCATION', STATE.chunk, STATE.tokens);
      STATE.insideInvocation.pop();
      if (STATE.stringInterpolation.nestedInvocation) {
        STATE.stringInterpolation.nestedInvocation = false;
      }
      STATE.advanceAndClear(1);
      module.exports.handleEndOfFile(STATE.nextCol, STATE.tokens);
      return true;
    }
    return false;
  },

  handleFunctionInvocationInside: function(STATE) {
    if (STATE.insideInvocation.length && STATE.chunk === '(' && (STATE.insideInvocation[STATE.insideInvocation.length - 1]).status) {
      module.exports.checkFor(STATE, 'PUNCTUATION', STATE.chunk, STATE.tokens);
      STATE.insideInvocation[STATE.insideInvocation.length - 1].parens++;
      STATE.advanceAndClear(1);
      return true;
    }
    if (STATE.insideInvocation.length && STATE.chunk === ')' && (STATE.insideInvocation[STATE.insideInvocation.length - 1]).status) {
      module.exports.checkFor(STATE, 'PUNCTUATION', STATE.chunk, STATE.tokens);
      STATE.insideInvocation[STATE.insideInvocation.length - 1].parens--;
      STATE.advanceAndClear(1);
      return true;
    }
    return false;
  },

  // helper function to handle function declarations
  handleFunctionDeclarationStart: function(STATE) {
    if (STATE.chunk === 'func') {
      module.exports.checkFor(STATE, 'KEYWORD', STATE.chunk, STATE.tokens);
      var temp = {};
      temp.status = true; // whether inside of a function declaration or not
      temp.insideParams = false; // 3-valued statement for whether not started, inside, or ended function parameters declaration
      temp.paramsParens = []; // handles the parenthesis in the parameters of the parent function
      temp.paramsCounter = 0; // add's 1 if encountered ( and subtracts 1 if encounter )
      temp.statements = 0; //number of statements where by a function statement start with a {
      temp.curly = 0; // all other { such as for loops are counted as curly
      temp.insideReturnStatement = false; // whether inside original function statement or not
      temp.returnArrows = [];
      temp.endFunctionParameterDeclarationIndex = -1;
      // temp.index = tokens.length - 1;
      STATE.insideFunction.push(temp);
      STATE.advanceAndClear(2);
      return true;
    }
    return false;
  },

  rewriteVariableParensHistory: function(STATE) {
    if (STATE.variableArrows.length)
    var arrowIndex = STATE.variableArrows[STATE.variableArrows.length - 1];
    var tok = STATE.tokens[arrowIndex];
    var arr = [];
    while (tok["value"] !== "var" && tok["value"] !== "let") {
      arrowIndex--;
      tok = STATE.tokens[arrowIndex];
      if (tok["value"] === '(' || tok["value"] === ')') {
        arr.push({tokenIndex: arrowIndex, tokenType: tok["type"], tokenValue: tok["value"]});
      }
    }
    module.exports.reviseFunctionHistory(arr, STATE);
    STATE.variableArrows.pop();
  },

  handleFunctionDeclarationInside: function(STATE) {
    if (STATE.insideFunction.length && STATE.chunk === '(' &&
      STATE.insideFunction[STATE.insideFunction.length - 1].insideParams === false) {
      STATE.FUNCTION_NAMES[STATE.lastToken.value] = true;
      module.exports.checkFor(STATE, 'FUNCTION_DECLARATION', STATE.chunk, STATE.tokens);
      STATE.insideFunction[STATE.insideFunction.length - 1].insideParams = true;
      STATE.insideFunction[STATE.insideFunction.length - 1].paramsParens.push({tokenIndex: STATE.tokens.length - 1, tokenType: "PARAMS_START", tokenValue: "("});
      STATE.insideFunction[STATE.insideFunction.length - 1].paramsCounter++;
      STATE.advanceAndClear(1);
      return true;
    }

    if (STATE.insideFunction.length && STATE.chunk === ')' && 
      STATE.insideFunction[STATE.insideFunction.length - 1].insideParams === true &&
      STATE.insideFunction[STATE.insideFunction.length - 1].paramsCounter === 1 ) {
      module.exports.checkFor(STATE, 'FUNCTION_DECLARATION', STATE.chunk, STATE.tokens);
      if (STATE.insideFunction[STATE.insideFunction.length - 1].endFunctionParameterDeclarationIndex === -1) {
        STATE.insideFunction[STATE.insideFunction.length - 1].endFunctionParameterDeclarationIndex = STATE.tokens.length - 1;
      }
      STATE.insideFunction[STATE.insideFunction.length - 1].paramsCounter--;
      STATE.insideFunction[STATE.insideFunction.length - 1].insideParams = "ended";
      STATE.insideFunction[STATE.insideFunction.length - 1].paramsParens.shift();
      module.exports.reviseFunctionHistory(STATE.insideFunction[STATE.insideFunction.length - 1].paramsParens, STATE);
      
      // END code to look back and revise incorrect ()'s

      STATE.advanceAndClear(1);
      return true;
    }

    if (STATE.insideFunction.length && STATE.chunk === ')' && 
      STATE.insideFunction[STATE.insideFunction.length - 1].insideReturnStatement === true && !STATE.insideInitialization.length) {
      module.exports.checkFor(STATE, 'FUNCTION_DECLARATION', STATE.chunk, STATE.tokens);
      STATE.insideFunction[STATE.insideFunction.length - 1].insideReturnStatement = "ended";
      STATE.advanceAndClear(1);
      return true;
    }

    if (STATE.insideFunction.length && STATE.chunk === '{' && 
      STATE.insideFunction[STATE.insideFunction.length - 1].statements === 0) {
      module.exports.checkFor(STATE, 'FUNCTION_DECLARATION', STATE.chunk, STATE.tokens);
      STATE.insideFunction[STATE.insideFunction.length - 1].statements++;
      STATE.insideFunction[STATE.insideFunction.length - 1].insideReturnStatement = true;
      //This is the place where we need to go back and count the number of ()'s then figure out what happened
      if (STATE.insideFunction[STATE.insideFunction.length - 1].returnArrows.length >= 2) { // may be needed to be changed to === 2
        var input = [];
        if (STATE.insideFunction[STATE.insideFunction.length - 1].returnArrows[0] > STATE.insideFunction[STATE.insideFunction.length - 1].endFunctionParameterDeclarationIndex) {
          var start = STATE.insideFunction[STATE.insideFunction.length - 1].returnArrows[0] ;
          for (var i = start, end = STATE.tokens.length-1; i < end; i++) {
            if (STATE.tokens[i]["value"] === '(' || STATE.tokens[i]["value"] === ')') {
              input.push({tokenIndex: i, tokenType: STATE.tokens[i]["type"], tokenValue: STATE.tokens[i]["value"]});
            }
          }
          module.exports.reviseFunctionHistory(input, STATE);
        }
      }
      STATE.advanceAndClear(1);
      return true;
    }
    if (STATE.insideFunction.length && STATE.chunk === '{' && 
      STATE.insideFunction[STATE.insideFunction.length - 1].statements === 1) {
      module.exports.checkFor(STATE, 'PUNCTUATION', STATE.chunk, STATE.tokens);
      STATE.insideFunction[STATE.insideFunction.length - 1].curly++;
      STATE.advanceAndClear(1);
      return true;
    }
    if (STATE.insideFunction.length && STATE.chunk === '}' && 
      STATE.insideFunction[STATE.insideFunction.length - 1].statements === 1 && 
      STATE.insideFunction[STATE.insideFunction.length - 1].curly > 0) {
      module.exports.checkFor(STATE, 'PUNCTUATION', STATE.chunk, STATE.tokens);
      STATE.insideFunction[STATE.insideFunction.length - 1].curly--;
      STATE.advanceAndClear(1);
      return true;
    }
    return false;
  },

  handleFunctionDeclarationEnd: function(STATE) {
    if (STATE.insideFunction.length && STATE.chunk === '}' && 
      STATE.insideFunction[STATE.insideFunction.length - 1].statements === 1 && 
      STATE.insideFunction[STATE.insideFunction.length - 1].curly === 0) {
      module.exports.checkFor(STATE, 'FUNCTION_DECLARATION', STATE.chunk, STATE.tokens);
      STATE.insideFunction.pop();
      STATE.advanceAndClear(1);
      module.exports.handleEndOfFile(STATE.nextCol, STATE.tokens);
      return true;
    }
    return false;
  },

  reviseFunctionHistory: function(inputArray, STATE) {
    var arr = [];
    var len = Math.floor((inputArray.length)/2);
    var obj = {
      "PUNCTUATION": function(tokenIndexStart, tokenIndexEnd) {
        STATE.tokens[tokenIndexStart]['type'] = "PUNCTUATION";
        STATE.tokens[tokenIndexEnd]['type'] = "PUNCTUATION";
      },
      "PARAMS": function(tokenIndexStart, tokenIndexEnd) {
        STATE.tokens[tokenIndexStart]['type'] = "PARAMS_START";
        STATE.tokens[tokenIndexEnd]['type'] = "PARAMS_END";
      },
      "TUPLE": function(tokenIndexStart, tokenIndexEnd) {
        STATE.tokens[tokenIndexStart]['type'] = "TUPLE_START";
        STATE.tokens[tokenIndexEnd]['type'] = "TUPLE_END";
        for (var q = tokenIndexEnd - 1, enda = tokenIndexStart + 1; q >= enda; q--) {
          if (STATE.tokens[q]['value'] === ':') {
            STATE.tokens[q-1]['type'] = "TUPLE_ELEMENT_NAME";
          }
        }
      }
    };
    for (var j = 0; j < len; j++) {
      var x = [];
      x.push((inputArray.splice(((inputArray.length)/2 - 1),1))[0]);
      x.push((inputArray.splice(Math.floor((inputArray.length)/2),1))[0]);
      arr.push(x);
    }
    // console.log("arr: ",arr);
    for (var j = 0; j < len; j++) {
      var y = arr[j];
      var toDo = "PUNCTUATION";
      for (var k = y[1]['tokenIndex'] - 1, z = y[0]['tokenIndex'] + 1; k >= z; k--) {
        if (STATE.tokens[k]['type'] === 'RETURN_ARROW') {
          toDo = "PUNCTUATION";
          break;
        } else if (STATE.tokens[k]['value'] === ',') {
          toDo = "PARAMS";
          break;
        } else if (STATE.tokens[k]['value'] === ':') {
          toDo = "TUPLE";
          break;
        } else if (STATE.tokens[k]['type'] === 'TYPE_BOOLEAN' || STATE.tokens[k]['type'] === 'TYPE_STRING' || STATE.tokens[k]['type'] === 'TYPE_NUMBER') {
          toDo = "PARAMS";
        } else {
          toDo = "PUNCTUATION";
        }
      }
      obj[toDo](y[0]['tokenIndex'],y[1]['tokenIndex']);
    }
  },

  // helper function to make token and add to tokens array
  makeToken: function(lexicalType, chunk, tokens, type, value) {
    if (tokens) {
      var obj = {};
      obj.type = type || lexicalTypes[lexicalType][chunk];
      obj.value = value || chunk.trim();
      tokens.push(obj);
    }
  },

  // helper function to handle new lines
  handleNewLine: function(STATE) {
    if (STATE.currCol === '\n') {
      module.exports.makeToken(undefined, undefined, STATE.tokens, 'TERMINATOR', '\\n');
      STATE.emptyLine = true;
      return true;
    }
    if (STATE.emptyLine && !module.exports.checkForWhitespace(STATE.currCol)) {
      STATE.emptyLine = false;
    }
    if (STATE.emptyLine && STATE.lastToken && STATE.lastToken.value === '\\n') {
      return true;
    }
    return false;
  },

  // checks for string and boolean values
  checkForLiteral: function(chunk, tokens, cb) {
    if (chunk) {
      chunk = JSON.parse(chunk.trim());
    }
    var type = typeof chunk;
    var obj = {
      'boolean': function(chunk, tokens) {
        if (tokens) {
          module.exports.makeToken(undefined, chunk, tokens, 'BOOLEAN', JSON.stringify(chunk));
        }
        if (cb) {cb(chunk, tokens)}
        return true;
      },
      'string': function(chunk, tokens) {
        if (tokens) {
          module.exports.makeToken(undefined, chunk, tokens, 'STRING', chunk);
        }
        if (cb) {cb(chunk, tokens)}
        return true;
      },
    };
    if (obj[type] === undefined) {
      return false;
    } else {
      obj[type](chunk, tokens);
    }
  },

  // handles start of multi-line and single-line comments
  checkForCommentStart: function(STATE) {
    if (STATE.currCol === '/' && STATE.nextCol === '*' && !(STATE.insideComment.multi && STATE.insideComment.single)) {
      STATE.insideComment.multi = true;
      STATE.chunk += STATE.nextCol;
      module.exports.checkFor(STATE, 'COMMENT', STATE.chunk, STATE.tokens);
      return true;
    }
    else if (STATE.currCol === '/' && STATE.nextCol === '/' && !(STATE.insideComment.multi && STATE.insideComment.single)) {
      STATE.insideComment.single = true;
      STATE.chunk += STATE.nextCol;
      module.exports.checkFor(STATE, 'COMMENT', STATE.chunk, STATE.tokens);
      return true;
    }
    return false;
  },

  // tokenizes comment contents and handles end of single and multi-line comments
  handleComment: function(STATE, cb) {
    if (STATE.insideComment.multi) {
      if (STATE.chunk === '*/') {
        module.exports.checkFor(STATE, 'COMMENT', STATE.chunk, STATE.tokens);
        STATE.insideComment.multi = false;
        if (STATE.nextCol === '\n') {
          STATE.advanceAndClear(1);
        } else {
          STATE.advanceAndClear(2);
        }
        return true;
      } else if ((STATE.nextCol === '*' && STATE.nextNextCol === '/') || STATE.nextCol === '\n') {
        module.exports.makeToken(undefined, undefined, STATE.tokens, 'COMMENT', STATE.chunk);
        STATE.advanceAndClear(1);
        return true;
      }
    }
    else if (STATE.insideComment.single && (STATE.nextCol === undefined || STATE.nextCol === '\n')) {
      STATE.insideComment.single = false;
      module.exports.makeToken(undefined, undefined, STATE.tokens, 'COMMENT', STATE.chunk);
      module.exports.handleEndOfFile(STATE.nextCol, STATE.tokens);
      STATE.advanceAndClear(1);
      return true;
    }
    return false;
  },

  checkIfInsideComment: function(STATE) {
    if (STATE.insideComment.multi || STATE.insideComment.single) {
      return true;
    }
    return false;
  },

  // main helper function to check whether chunk is a Swift lexical type
  checkFor: function(STATE, lexicalType, chunk, tokens, cb) {
    if (chunk) {
      chunk = chunk.trim();
    }
    if(lexicalTypes[lexicalType][chunk]){
      if (tokens) {
        module.exports.makeToken(lexicalType, chunk, tokens);
        var recentFunc = STATE.insideFunction[STATE.insideFunction.length - 1];
        if (lexicalType === "PUNCTUATION" &&
            chunk === "(" &&
            STATE.insideFunction.length &&
            STATE.insideFunction[STATE.insideFunction.length - 1].insideParams === true &&
            recentFunc.paramsParens.length &&
            recentFunc.paramsParens[recentFunc.paramsParens.length - 1]["tokenIndex"] !== STATE.tokens.length - 1) {
          recentFunc.paramsCounter++;
          recentFunc.paramsParens.push({tokenIndex: STATE.tokens.length - 1, tokenType: "PUNCTUATION", tokenValue: "("});
        }
        if (lexicalType === "PUNCTUATION" &&
            chunk === ")" &&
            STATE.insideFunction.length &&
            STATE.insideFunction[STATE.insideFunction.length - 1].insideParams === true &&
            recentFunc.paramsParens.length &&
            recentFunc.paramsParens[recentFunc.paramsParens.length - 1]["tokenIndex"] !== STATE.tokens.length - 1) {
          STATE.insideFunction[STATE.insideFunction.length - 1].paramsCounter--;
          STATE.insideFunction[STATE.insideFunction.length - 1].paramsParens.push({tokenIndex: STATE.tokens.length - 1, tokenType: "PUNCTUATION", tokenValue: ")"});
        }
        if (cb) {
          cb();
        }
      }
      return true;
    }
    return false;
  },

  // helper function to handle numbers, including numbers written with underscores
  handleNumber: function(STATE, cb) {
    if (NUMBER.test(STATE.chunk) && !STATE.insideString && !STATE.insideNumber) {
      STATE.insideNumber = true;
    }
    // have an _ in the input
    if (STATE.insideNumber && STATE.nextCol === '_') {
      return "skip";
    }

    //have an integer or decimal
    if (STATE.insideNumber && (STATE.nextCol === '\n' ||
      (isNaN(STATE.nextCol) && (STATE.nextCol !== '.') && (STATE.nextNextCol !== '.')))) {
      STATE.insideNumber = false;
      module.exports.makeToken(undefined, STATE.chunk, STATE.tokens, 'NUMBER', STATE.chunk.trim());
      module.exports.handleEndOfFile(STATE.nextCol, STATE.tokens);
      return true;
    }

    //have a range
    if (STATE.insideNumber && (STATE.nextCol === '.') && (STATE.nextNextCol === '.')) {
      STATE.insideNumber = false;
      module.exports.makeToken(undefined, STATE.chunk, STATE.tokens, 'NUMBER', STATE.chunk.trim());
      module.exports.handleEndOfFile(STATE.nextCol, STATE.tokens);
      return true;
    }
  },
  
  // helper function to handle range operators
  handleRange: function(STATE) {
    if (!STATE.insideString && !module.exports.checkIfInsideComment(STATE)) {
      if (STATE.currCol === '.' && STATE.nextCol === '.' && STATE.nextNextCol === '.') {
        if (STATE.insideFunction.length && STATE.insideFunction[STATE.insideFunction.length - 1].insideParams === true) {
          module.exports.checkFor(STATE, 'FUNCTION_DECLARATION', '...', STATE.tokens);
          return true;
        } else {
          module.exports.checkFor(STATE, 'RANGE', '...', STATE.tokens);
          return true;
        }
      }
      if (STATE.currCol === '.' && STATE.nextCol === '.' && STATE.nextNextCol === '<') {
        module.exports.checkFor(STATE, 'RANGE', '..<', STATE.tokens);
        return true;
      }
    }
    return false;
  },

  checkForStringInterpolationStart: function(STATE) {
    if (!STATE.stringInterpolation.status && STATE.nextCol === '\\' && STATE.nextNextCol === '(') {
      STATE.stringInterpolation.status = true;
      if (STATE.chunk !== "") {
        module.exports.checkForLiteral(STATE.chunk + '"', STATE.tokens);
      }
      module.exports.makeToken("SPECIAL_STRING", "\\(", STATE.tokens);
      STATE.insideString = false;
      return true;
    }
  },

  checkForStringInterpolationEnd: function(STATE) {
    if (STATE.stringInterpolation.status && STATE.currCol === ")" &&
      !STATE.stringInterpolation.nestedInvocation) {
      STATE.stringInterpolation.status = false;
      module.exports.makeToken("SPECIAL_STRING", ")", STATE.tokens);
      STATE.insideString = true;
      return true;
    }
  },
  
  
  // handles classes and structures
  handleClassOrStruct: function(STATE) {
    if (STATE.insideClass.length && STATE.insideClass[STATE.insideClass.length - 1].curly === 0 && STATE.chunk === '{') {
      module.exports.checkFor(STATE, 'CLASS_DEFINITION', STATE.chunk, STATE.tokens);
      STATE.insideClass[STATE.insideClass.length - 1].curly++;
      return true;
    }
    if (STATE.insideClass.length && STATE.insideClass[STATE.insideClass.length - 1].curly === 1 && STATE.chunk === '}') {
      module.exports.checkFor(STATE, 'CLASS_DEFINITION', STATE.chunk, STATE.tokens);
      STATE.insideClass.pop();
      module.exports.handleEndOfFile(STATE.nextCol, STATE.tokens);
      return true;
    }
    if (STATE.insideStruct.length && STATE.insideStruct[STATE.insideStruct.length - 1].curly === 0 &&
      STATE.chunk === '{') {
      module.exports.checkFor(STATE, 'STRUCT_DEFINITION', STATE.chunk, STATE.tokens);
      STATE.insideStruct[STATE.insideStruct.length - 1].curly++;
      return true;
    }
    if (STATE.insideStruct.length && STATE.insideStruct[STATE.insideStruct.length - 1].curly === 1 &&
      STATE.chunk === '}') {
      module.exports.checkFor(STATE, 'STRUCT_DEFINITION', STATE.chunk, STATE.tokens);
      STATE.insideStruct.pop();
      module.exports.handleEndOfFile(STATE.nextCol, STATE.tokens);
      return true;
    }
    if (STATE.tokens.length && (STATE.CLASS_NAMES[STATE.lastToken.value] || 
      STATE.STRUCT_NAMES[STATE.lastToken.value]) && STATE.chunk === '(') {
      module.exports.checkFor(STATE, 'INITIALIZATION', STATE.chunk, STATE.tokens)
      var temp = {};
      temp.status = true;
      temp.parens = 1;
      STATE.insideInitialization.push(temp);
      return true;
    }
    if (STATE.chunk === ')' && STATE.insideInitialization.length && 
      STATE.insideInitialization[STATE.insideInitialization.length - 1].parens === 1) {
      module.exports.checkFor(STATE, 'INITIALIZATION', STATE.chunk, STATE.tokens);
      STATE.insideInitialization.pop();
      module.exports.handleEndOfFile(STATE.nextCol, STATE.tokens);
      return true;
    }
    return false;
  },
  
  checkForTupleStart: function(STATE) {
    if (!STATE.insideTuple.status && STATE.currCol === '(' && ((STATE.lastToken.value === '=' ||
      STATE.lastToken.value === 'return' || STATE.lastToken.value === '->') || (STATE.insideInvocation.length && STATE.insideInvocation[STATE.insideInvocation.length - 1].status)) ) {
      module.exports.makeToken(undefined, undefined, STATE.tokens,'TUPLE_START', STATE.chunk);
      // special handling of empty tuples
      if (STATE.insideInvocation.length && STATE.insideInvocation[STATE.insideInvocation.length - 1].status) {
        STATE.insideInvocation[STATE.insideInvocation.length - 1].parens++;
      }
      if (STATE.nextCol === ')') {
        module.exports.makeToken(undefined, undefined, STATE.tokens, 'TUPLE_END', STATE.nextCol);
        module.exports.handleEndOfFile(STATE.nextNextCol, STATE.tokens);
        STATE.advanceAndClear(1);
      } else {
        STATE.insideTuple.status = true;
        STATE.insideTuple.startIndex = STATE.tokens.length - 1;
      }
      return true;
    }
    return false;
  },

  handleTuple: function(STATE) {
    if (STATE.nextCol === ':') {
      module.exports.makeToken(undefined, undefined, STATE.tokens, 'TUPLE_ELEMENT_NAME', STATE.chunk);
      STATE.TUPLE_ELEMENT_NAMES[STATE.chunk] = true;
      return true;
    } else if (STATE.currCol === ',') {
      STATE.insideTuple.verified = true;
      return false
    }
  },

  checkForTupleEnd: function(STATE) {
    if (STATE.insideTuple.status && STATE.currCol === ')') {
      if (STATE.insideTuple.verified) {
        module.exports.makeToken(undefined, undefined, STATE.tokens, 'TUPLE_END', STATE.chunk);
        if (STATE.insideInvocation.length && STATE.insideInvocation[STATE.insideInvocation.length - 1].status) {
          STATE.insideInvocation[STATE.insideInvocation.length - 1].parens--;
        }
        STATE.insideTuple.status = false;
        STATE.insideTuple.startIndex = undefined;
        STATE.insideTuple.verified = false;
        return true;
      } else {
        STATE.tokens[STATE.insideTuple.startIndex].type = 'PUNCTUATION';
        STATE.insideTuple.status = false;
        STATE.insideTuple.startIndex = undefined;
        STATE.insideTuple.verified = false;
        return false;
      }
    }
  },

  // helper function to check for identifiers
  checkForIdentifier: function(STATE) {
    if (STATE.VARIABLE_NAMES[STATE.chunk]) {
      if (STATE.tokens) {
        module.exports.makeToken(undefined, STATE.chunk, STATE.tokens, 'IDENTIFIER', STATE.chunk);
      }
      return true;
    } else if (STATE.lastToken && (STATE.lastToken.type === 'DECLARATION_KEYWORD' ||
      STATE.lastToken.value === 'for' ||
      
      // special condition for multiple variables of the same type declared on a single line
      (STATE.lastToken.value === ',' && STATE.VARIABLE_NAMES[STATE.tokens[STATE.tokens.length -2].value] && !STATE.insideInvocation.length) ||

        // special conditions to handle for-in loops that iterate over dictionaries
      (STATE.lastToken.value === '(' && STATE.tokens[STATE.tokens.length - 2].value === 'for') ||
      (STATE.lastToken.value === ',' && STATE.tokens[STATE.tokens.length - 3].value) === '(' &&
      STATE.tokens[STATE.tokens.length - 4].value === 'for' || (STATE.insideFunction.length && STATE.insideFunction[STATE.insideFunction.length - 1].insideParams === true && STATE.lastToken.value !== '='))) {
      if (STATE.tokens) {
        module.exports.makeToken(undefined, STATE.chunk, STATE.tokens, 'IDENTIFIER', STATE.chunk);
      }
      STATE.VARIABLE_NAMES[STATE.chunk] = true;
      
      // special conditions to handle identifiers for classes and structs
      if (STATE.tokens[STATE.tokens.length - 2].value === 'class') {
        var temp = {};
        temp.status = true;
        temp.curly = 0;
        STATE.insideClass.push(temp);
        STATE.CLASS_NAMES[STATE.chunk] = true;
      }
      if (STATE.tokens[STATE.tokens.length - 2].value === 'struct') {
        var temp = {};
        temp.status = true;
        temp.curly = 0;
        STATE.insideStruct.push(temp);
        STATE.STRUCT_NAMES[STATE.chunk] = true;
      }
      return true;
    }
    return false;
  },

  determineCollectionType: function(STATE, cb) {
    if (STATE.tokens[STATE.tokens.length - 1].value === ':') {
      STATE.tokens[STATE.insideCollection[STATE.insideCollection.length - 1].location].type = 'DICTIONARY_START';
      STATE.insideCollection[STATE.insideCollection.length - 1].type = 'DICTIONARY_END';
    } else {
      STATE.insideCollection[STATE.insideCollection.length - 1].type  = 'ARRAY_END';
    }
    if (cb) {
      cb();
    }
  },

  handleEndOfFile: function(col, tokens) {
    if (col === undefined) module.exports.makeToken(undefined, undefined, tokens, 'TERMINATOR', 'EOF');
  }

};

module.exports = {

  CLASS_DEFINITION: {
    '{': 'CLASS_DEFINITION_START',
    '}': 'CLASS_DEFINITION_END',
  },

  COLLECTION: {
    '[': 'ARRAY_START',
    ']': 'COLLECTION_END',
  },

  COMMENT: {
    '//': 'COMMENT_START',
    '/*': 'MULTI_LINE_COMMENT_START',
    '*/': 'MULTI_LINE_COMMENT_END' ,
  },

  FUNCTION_DECLARATION: {
    '(': 'PARAMS_START',
    ')': 'PARAMS_END',
    '{': 'STATEMENTS_START',
    '}': 'STATEMENTS_END',
    '->': 'RETURN_ARROW',
    '...': 'VARIADIC_PARAM',
  },

  FUNCTION_INVOCATION: {
    '(': 'INVOCATION_START',
    ')': 'INVOCATION_END',
  },

  INITIALIZATION: {
    '(': 'INITIALIZATION_START',
    ')': 'INITIALIZATION_END',
  },

  KEYWORD: {

    // keywords used in declarations
    'class': 'DECLARATION_KEYWORD',
    'deinit': 'DECLARATION_KEYWORD',
    'enum': 'DECLARATION_KEYWORD',
    'extension': 'DECLARATION_KEYWORD',
    'func': 'DECLARATION_KEYWORD',
    'import': 'DECLARATION_KEYWORD',
    'init': 'DECLARATION_KEYWORD',
    'inout': 'DECLARATION_KEYWORD',
    'internal': 'DECLARATION_KEYWORD',
    'let': 'DECLARATION_KEYWORD',
    'operator': 'DECLARATION_KEYWORD',
    'private': 'DECLARATION_KEYWORD',
    'protocol': 'DECLARATION_KEYWORD',
    'public': 'DECLARATION_KEYWORD',
    'static': 'DECLARATION_KEYWORD',
    'struct': 'DECLARATION_KEYWORD',
    'subscript': 'DECLARATION_KEYWORD',
    'typealias': 'DECLARATION_KEYWORD',
    'var': 'DECLARATION_KEYWORD',

    // keywords used in statements
    'break': 'STATEMENT_KEYWORD',
    'case': 'STATEMENT_KEYWORD',
    'continue': 'STATEMENT_KEYWORD',
    'default': 'STATEMENT_KEYWORD',
    'defer': 'STATEMENT_KEYWORD',
    'do': 'STATEMENT_KEYWORD',
    'else': 'STATEMENT_KEYWORD',
    'fallthrough': 'STATEMENT_KEYWORD',
    'for': 'STATEMENT_KEYWORD',
    'guard': 'STATEMENT_KEYWORD',
    'if': 'STATEMENT_KEYWORD',
    'in': 'STATEMENT_KEYWORD',
    'repeat': 'STATEMENT_KEYWORD',
    'return': 'STATEMENT_KEYWORD',
    'switch': 'STATEMENT_KEYWORD',
    'where': 'STATEMENT_KEYWORD',
    'while': 'STATEMENT_KEYWORD',

    // keywords used in expressions and types
    'as': 'EXPRESSION_OR_TYPE_KEYWORD',
    'catch': 'EXPRESSION_OR_TYPE_KEYWORD',
    'dynamicType': 'EXPRESSION_OR_TYPE_KEYWORD',
    'is': 'EXPRESSION_OR_TYPE_KEYWORD',
    'nil': 'EXPRESSION_OR_TYPE_KEYWORD',
    'rethrows': 'EXPRESSION_OR_TYPE_KEYWORD',
    'super': 'EXPRESSION_OR_TYPE_KEYWORD',
    'self': 'EXPRESSION_OR_TYPE_KEYWORD',
    'Self': 'EXPRESSION_OR_TYPE_KEYWORD',
    'throw': 'EXPRESSION_OR_TYPE_KEYWORD',
    'throws': 'EXPRESSION_OR_TYPE_KEYWORD',
    'try': 'EXPRESSION_OR_TYPE_KEYWORD',
    '__COLUMN__': 'EXPRESSION_OR_TYPE_KEYWORD',
    '__FILE__': 'EXPRESSION_OR_TYPE_KEYWORD',
    '__FUNCTION__': 'EXPRESSION_OR_TYPE_KEYWORD',
    '__LINE__': 'EXPRESSION_OR_TYPE_KEYWORD',

    // keywords used in patterns
    '_': 'PATTERN_KEYWORD',

    // keywords reserved in particular contexts
    'associativity': 'CONTEXT_SPECIFIC_KEYWORD',
    'convenience': 'CONTEXT_SPECIFIC_KEYWORD',
    'dynamic': 'CONTEXT_SPECIFIC_KEYWORD',
    'didSet': 'CONTEXT_SPECIFIC_KEYWORD',
    'final': 'CONTEXT_SPECIFIC_KEYWORD',
    'get': 'CONTEXT_SPECIFIC_KEYWORD',
    'infix': 'CONTEXT_SPECIFIC_KEYWORD',
    'indirect': 'CONTEXT_SPECIFIC_KEYWORD',
    'lazy': 'CONTEXT_SPECIFIC_KEYWORD',
    'left': 'CONTEXT_SPECIFIC_KEYWORD',
    'mutating': 'CONTEXT_SPECIFIC_KEYWORD',
    'none': 'CONTEXT_SPECIFIC_KEYWORD',
    'nonmutating': 'CONTEXT_SPECIFIC_KEYWORD',
    'optional': 'CONTEXT_SPECIFIC_KEYWORD',
    'override': 'CONTEXT_SPECIFIC_KEYWORD',
    'postfix': 'CONTEXT_SPECIFIC_KEYWORD',
    'precedence': 'CONTEXT_SPECIFIC_KEYWORD',
    'prefix': 'CONTEXT_SPECIFIC_KEYWORD',
    'Protocol': 'CONTEXT_SPECIFIC_KEYWORD',
    'required': 'CONTEXT_SPECIFIC_KEYWORD',
    'right': 'CONTEXT_SPECIFIC_KEYWORD',
    'set': 'CONTEXT_SPECIFIC_KEYWORD',
    'Type': 'CONTEXT_SPECIFIC_KEYWORD',
    'unowned': 'CONTEXT_SPECIFIC_KEYWORD',
    'weak': 'CONTEXT_SPECIFIC_KEYWORD',
    'willSet': 'CONTEXT_SPECIFIC_KEYWORD',

  },

  METHOD_ARGUMENT_NAME: {
    'at': 'METHOD_ARGUMENT_NAME',
    'atIndex': 'METHOD_ARGUMENT_NAME',
    'forKey': 'METHOD_ARGUMENT_NAME',
    'repeatedValue': 'METHOD_ARGUMENT_NAME',
  },

  NATIVE_METHOD: {
    'abs': 'NATIVE_METHOD',
    'advancedBy': 'NATIVE_METHOD',
    'append': 'NATIVE_METHOD',
    'contains': 'NATIVE_METHOD',
    'distanceTo': 'NATIVE_METHOD',
    'dropFirst': 'NATIVE_METHOD',
    'dropLast': 'NATIVE_METHOD',
    'elementsEqual': 'NATIVE_METHOD',
    'hasPrefix': 'NATIVE_METHOD',
    'hasSuffix': 'NATIVE_METHOD',
    'insert': 'NATIVE_METHOD',
    'insertContentsOf': 'NATIVE_METHOD',
    'maxElement': 'NATIVE_METHOD',
    'minElement': 'NATIVE_METHOD',
    'predecessor': 'NATIVE_METHOD',
    'popLast': 'NATIVE_METHOD',
    'print': 'NATIVE_METHOD',
    'removeAtIndex': 'NATIVE_METHOD',
    'removeAll': 'NATIVE_METHOD',
    'removeFirst': 'NATIVE_METHOD',
    'removeLast': 'NATIVE_METHOD',
    'removeRange': 'NATIVE_METHOD',
    'removeValueForKey': 'NATIVE_METHOD',
    'replaceRange': 'NATIVE_METHOD',
    'successor': 'NATIVE_METHOD',
    'startsWith': 'NATIVE_METHOD',
    'updateValue': 'NATIVE_METHOD',
  },

  OPERATOR: {
    '/': 'OPERATOR',
    '=': 'OPERATOR',
    '-': 'OPERATOR',
    '+': 'OPERATOR',
    '!': 'OPERATOR',
    '*': 'OPERATOR',
    '%': 'OPERATOR',
    '<': 'OPERATOR',
    '>': 'OPERATOR',
    '&': 'OPERATOR',
    '|': 'OPERATOR',
    '^': 'OPERATOR',
    '?': 'OPERATOR',
    '~': 'OPERATOR',
  },

  PUNCTUATION: {
    '(': 'PUNCTUATION',
    ')': 'PUNCTUATION',
    '{': 'PUNCTUATION',
    '}': 'PUNCTUATION',
    '.': 'PUNCTUATION',
    ',': 'PUNCTUATION',
    ':': 'PUNCTUATION',
    ';': 'PUNCTUATION',
    '@': 'PUNCTUATION',
    '#': 'PUNCTUATION',
    '`': 'PUNCTUATION',
  },

  RANGE: {
    '...': 'CLOSED_RANGE',
    '..<': 'HALF_OPEN_RANGE',
  },

  SUBSCRIPT_LOOKUP: {
    '[': 'SUBSCRIPT_LOOKUP_START',
    ']': 'SUBSCRIPT_LOOKUP_END',
  },

  SPECIAL_STRING: {
    '\\(': "STRING_INTERPOLATION_START",
    ')': "STRING_INTERPOLATION_END",
  },

  STRUCT_DEFINITION: {
    '{': 'STRUCT_DEFINITION_START',
    '}': 'STRUCT_DEFINITION_END',
  },

  TERMINATOR: {
    'EOF': 'TERMINATOR',
    '\\n': 'TERMINATOR',
    '\\r': 'TERMINATOR',
    '\\t': 'TAB',
  },

  TYPE: {
    'Character': 'TYPE_STRING',
    'Double': 'TYPE_NUMBER',
    'Float': 'TYPE_NUMBER',
    'Bool': 'TYPE_BOOLEAN',
    'Int': 'TYPE_NUMBER',
    'Int8': 'TYPE_NUMBER',
    'Int16': 'TYPE_NUMBER',
    'Int32': 'TYPE_NUMBER',
    'Int64': 'TYPE_NUMBER',
    'String': 'TYPE_STRING',
    'UInt': 'TYPE_NUMBER',
    'UInt8': 'TYPE_NUMBER',
    'UInt16': 'TYPE_NUMBER',
    'UInt32': 'TYPE_NUMBER',
    'UInt64': 'TYPE_NUMBER',
  },

  TYPE_PROPERTY: {
    'characters': 'TYPE_PROPERTY',
    'count': 'TYPE_PROPERTY',
    'description': 'TYPE_PROPERTY',
    'endIndex': 'TYPE_PROPERTY',
    'lowercaseString': 'TYPE_PROPERTY',
    'isEmpty': 'TYPE_PROPERTY',
    'startIndex': 'TYPE_PROPERTY',
    'uppercaseString': 'TYPE_PROPERTY',
  },

};

var lexicalTypes = require("./lexicalTypes");

var NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;

module.exports = {

  // helper function to check for whitespace
  checkForWhitespace: function(chunk) {
    return chunk === ' ';
  },
  
  // default check for point at which to evaluate chunk
  checkForEvaluationPoint: function(currCol, nextCol) {
    if (

      module.exports.checkForWhitespace(currCol) ||
      module.exports.checkForWhitespace(nextCol) ||
      module.exports.checkFor('PUNCTUATION', nextCol) ||
      module.exports.checkFor('PUNCTUATION', currCol) ||
      module.exports.checkFor('OPERATOR', nextCol) ||
      module.exports.checkFor('OPERATOR', currCol) ||
      nextCol === '"' || nextCol === ']' || currCol === '[' ||
      currCol === ']' || nextCol === '[' || nextCol === '\n' ||
      nextCol === undefined

    ) {

      return true;

    }
    return false;
  },

  // helper function to handle function invocation
  handleFunctionInvocation: function(chunk, nextCol, tokens, lastToken, FUNCTION_NAMES, insideInvocation) {
    if (chunk === '(' && ((FUNCTION_NAMES[lastToken.value] && 
      tokens[tokens.length - 2].value !== 'func') || lastToken.type === 'NATIVE_METHOD')) {
      module.exports.checkFor('FUNCTION_INVOCATION', chunk, tokens);
      var tmp = {};
      tmp.name = lastToken.value;
      tmp.status = true;
      tmp.parens = 0;
      insideInvocation.push(tmp);
      return "cb1";
    }
    
    if (insideInvocation.length && (insideInvocation[insideInvocation.length - 1]).status && chunk === ')' && 
      (insideInvocation[insideInvocation.length - 1]).parens === 0) {
      module.exports.checkFor('FUNCTION_INVOCATION', chunk, tokens);
      var last = insideInvocation[insideInvocation.length - 1]; //may be unnecessary
      last.status = false; //may be unnecessary since poping next
      insideInvocation.pop();
      return "cb2";
    }

    if (insideInvocation.length && chunk === '(' && (insideInvocation[insideInvocation.length - 1]).status) {
      module.exports.checkFor('PUNCTUATION', chunk, tokens);
      var last = insideInvocation[insideInvocation.length - 1];
      last.parens++;
      return "cb1";
    }

    if (insideInvocation.length && chunk === ')' && (insideInvocation[insideInvocation.length - 1]).status) {
      module.exports.checkFor('PUNCTUATION', chunk, tokens);
      var last = insideInvocation[insideInvocation.length - 1];
      last.parens--;
      return "cb1";
    }
    
    return false;
  },

  // helper function to make token and add to tokens array
  makeToken: function(lexicalType, chunk, tokens, type, value) {
    if (tokens) {
      var obj = {};
      obj.type = type || lexicalTypes[lexicalType][chunk];
      obj.value = value || chunk.trim();
      tokens.push(obj);
    }
  },

  // helper function to handle new lines
  handleNewLine: function(emptyLine, tokens, lastToken, currCol) {
    if (currCol === '\n') {
      module.exports.makeToken(undefined, undefined, tokens, 'TERMINATOR', '\\n');
      emptyLine.status = true;
      return true;
    }
    if (emptyLine.status && !module.exports.checkForWhitespace(currCol)) {
      emptyLine.status = false;
    }
    if (emptyLine.status && lastToken && lastToken.value === '\\n') {
      return true;
    }
    return false;
  },

  // checks for string and boolean values
  checkForLiteral: function(chunk, tokens, cb) {
    if (chunk) {
      chunk = JSON.parse(chunk.trim());
    }
    var type = typeof chunk;
    var obj = {
      'boolean': function(chunk, tokens) {
        if (tokens) {
          module.exports.makeToken(undefined, chunk, tokens, 'BOOLEAN', JSON.stringify(chunk));
        }
        if (cb) {cb(chunk, tokens)}
        return true;
      },
      'string': function(chunk, tokens) {
        if (tokens) {
          module.exports.makeToken(undefined, chunk, tokens, 'STRING', chunk);
        }
        if (cb) {cb(chunk, tokens)}
        return true;
      },
    };
    if (obj[type] === undefined) {
      return false;
    } else {
      obj[type](chunk, tokens);
    }
  },

  // handles start of multi-line and single-line comments
  checkForCommentStart: function(insideComment, chunk, tokens, currCol,
                                 nextCol) {
    if (currCol === '/' && nextCol === '*' && !(insideComment.multi && insideComment.single)) {
      insideComment.multi = true;
      chunk += nextCol;
      module.exports.checkFor('COMMENT', chunk, tokens);
      return true;
    }
    else if (currCol === '/' && nextCol === '/' && !(insideComment.multi && insideComment.single)) {
      insideComment.single = true;
      chunk += nextCol;
      module.exports.checkFor('COMMENT', chunk, tokens);
      return true;
    }
    return false;
  },

  // tokenizes comment contents and handles end of single and multi-line comments
  handleComment: function(insideComment, chunk, tokens, currCol, nextCol, nextNextCol, cb) {
    if (insideComment.multi) {
      if (chunk === '*/') {
        module.exports.checkFor('COMMENT', chunk, tokens);
        insideComment.multi = false;
        if (nextCol === '\n') {
          cb(1);
        } else {
          cb(2);
        }
        return true;
      } else if ((nextCol === '*' && nextNextCol === '/') || nextCol === '\n') {
        module.exports.makeToken(undefined, undefined, tokens, 'COMMENT', chunk);
        cb(1);
        return true;
      }
    }
    else if (insideComment.single && (nextCol === undefined || nextCol === '\n')) {
      insideComment.single = false;
      module.exports.makeToken(undefined, undefined, tokens, 'COMMENT', chunk);
      module.exports.handleEndOfFile(nextCol, tokens);
      cb(1);
      return true;
    }
    return false;
  },

  checkIfInsideComment: function(insideComment) {
    if (insideComment.multi || insideComment.single) {
      return true;
    }
    return false;
  },

  // main helper function to check whether chunk is a Swift lexical type
  checkFor: function(lexicalType, chunk, tokens, cb) {
    if (chunk) {
      chunk = chunk.trim();
    }
    if(lexicalTypes[lexicalType][chunk]){
      if (tokens) {
        module.exports.makeToken(lexicalType, chunk, tokens);
        if (cb) {
          cb();
        }
      }
      return true;
    }
    return false;
  },

  // helper function to handle numbers, including numbers written with underscores
  handleNumber: function(insideString, insideNumber, chunk, tokens, nextCol, nextNextCol, cb) {
    if (NUMBER.test(chunk) && !insideString.status && !insideNumber.status) {
      insideNumber.status = true;
    }
    // have an _ in the input
    if (insideNumber.status && nextCol === '_') {
      return "skip";
    }

    //have an integer or decimal
    if (insideNumber.status && (nextCol === '\n' ||
      (isNaN(nextCol) && (nextCol !== '.') && (nextNextCol !== '.')))) {
      insideNumber.status = false;
      module.exports.makeToken(undefined, chunk, tokens, 'NUMBER', chunk.trim());
      module.exports.handleEndOfFile(nextCol, tokens);
      return true;
    }

    //have a range
    if (insideNumber.status && (nextCol === '.') && (nextNextCol === '.')) {
      insideNumber.status = false;
      module.exports.makeToken(undefined, chunk, tokens, 'NUMBER', chunk.trim());
      module.exports.handleEndOfFile(nextCol, tokens);
      return true;
    }
  },
  
  // helper function to handle range operators
  handleRange: function(insideString, insideFunction, insideComment, 
                        tokens, currCol, nextCol, nextNextCol) {
    if (!insideString.status && !module.exports.checkIfInsideComment(insideComment)) {
      if (currCol === '.' && nextCol === '.' && nextNextCol === '.') {
        if (insideFunction.length && insideFunction[insideFunction.length - 1].insideParams === true) {
          module.exports.checkFor('FUNCTION_DECLARATION', '...', tokens);
          return true;
        } else {
          module.exports.checkFor('RANGE', '...', tokens);
          return true;
        }
      }
      if (currCol === '.' && nextCol === '.' && nextNextCol === '<') {
        module.exports.checkFor('RANGE', '..<', tokens);
        return true;
      }
    }
    return false;
  },

  checkForStringInterpolationStart: function(stringInterpolation, insideString,
                                             chunk, tokens, nextCol, nextNextCol) {
    if (!stringInterpolation.status && nextCol === '\\' && nextNextCol === '(') {
      stringInterpolation.status = true;
      if (chunk !== "") {
        module.exports.checkForLiteral(chunk + '"', tokens);
      }
      module.exports.makeToken("SPECIAL_STRING", "\\(", tokens);
      insideString.status = false;
      return true;
    }
  },

  checkForStringInterpolationEnd: function(stringInterpolation, insideString,
                                           tokens, currCol) {
    if (stringInterpolation.status && currCol === ")") {
      stringInterpolation.status = false;
      module.exports.makeToken("SPECIAL_STRING", ")", tokens);
      insideString.status = true;
      return true;
    }
  },
  
  
  // handles classes and structures
  handleClassOrStruct: function(insideClass, insideStruct, insideInitialization,
                                chunk, tokens, lastToken, nextCol, CLASS_NAMES,
                                STRUCT_NAMES) {
    if (insideClass.length && insideClass[insideClass.length - 1].curly === 0 &&
      chunk === '{') {
      module.exports.checkFor('CLASS_DEFINITION', chunk, tokens);
      insideClass[insideClass.length - 1].curly++;
      return true;
    }
    if (insideClass.length && insideClass[insideClass.length - 1].curly === 1 &&
      chunk === '}') {
      module.exports.checkFor('CLASS_DEFINITION', chunk, tokens);
      insideClass.pop();
      module.exports.handleEndOfFile(nextCol, tokens);
      return true;
    }
    if (insideStruct.length && insideStruct[insideStruct.length - 1].curly === 0 &&
      chunk === '{') {
      module.exports.checkFor('STRUCT_DEFINITION', chunk, tokens);
      insideStruct[insideStruct.length - 1].curly++;
      return true;
    }
    if (insideStruct.length && insideStruct[insideStruct.length - 1].curly === 1 &&
      chunk === '}') {
      module.exports.checkFor('STRUCT_DEFINITION', chunk, tokens);
      insideStruct.pop();
      module.exports.handleEndOfFile(nextCol, tokens);
      return true;
    }
    if (tokens.length && (CLASS_NAMES[lastToken.value] || 
      STRUCT_NAMES[lastToken.value]) && chunk === '(') {
      module.exports.checkFor('INITIALIZATION', chunk, tokens)
      var temp = {};
      temp.status = true;
      temp.parens = 1;
      insideInitialization.push(temp);
      return true;
    }
    if (chunk === ')' && insideInitialization.length && 
      insideInitialization[insideInitialization.length - 1].parens === 1) {
      module.exports.checkFor('INITIALIZATION', chunk, tokens);
      insideInitialization.pop();
      module.exports.handleEndOfFile(nextCol, tokens);
      return true;
    }
    return false;
  },
  
  checkForTupleStart: function(insideTuple, chunk, tokens, lastToken,
                               currCol, nextCol, nextNextCol, cb) {
    if (!insideTuple.status && currCol === '(' && (lastToken.value === '=' ||
      lastToken.value === 'return' || lastToken.value === '->') ) {
      module.exports.makeToken(undefined, undefined, tokens,
        'TUPLE_START', chunk);
      // special handling of empty tuples
      if (nextCol === ')') {
        module.exports.makeToken(undefined, undefined, tokens, 'TUPLE_END', nextCol);
        module.exports.handleEndOfFile(nextNextCol, tokens);
        cb(1);
      } else {
        insideTuple.status = true;
        insideTuple.startIndex = tokens.length - 1;
      }
      return true;
    }
    return false;
  },

  handleTuple: function(insideTuple, chunk, tokens, currCol, nextCol, TUPLE_ELEMENT_NAMES) {
    if (nextCol === ':') {
      module.exports.makeToken(undefined, undefined, tokens, 'TUPLE_ELEMENT_NAME', chunk);
      TUPLE_ELEMENT_NAMES[chunk] = true;
      return true;
    } else if (currCol === ',') {
      insideTuple.verified = true;
      return false
    }
  },

  checkForTupleEnd: function(insideTuple, chunk, tokens, currCol) {
    if (insideTuple.status && currCol === ')') {
      if (insideTuple.verified) {
        module.exports.makeToken(undefined, undefined, tokens, 'TUPLE_END', chunk);
        insideTuple.status = false;
        insideTuple.startIndex = undefined;
        insideTuple.verified = false;
        return true;
      } else {
        tokens[insideTuple.startIndex].type = 'PUNCTUATION';
        insideTuple.status = false;
        insideTuple.startIndex = undefined;
        insideTuple.verified = false;
        return false;
      }
    }
  },

  // helper function to check for identifiers
  checkForIdentifier: function(chunk, tokens, lastToken, VARIABLE_NAMES, insideFunction, insideClass, insideStruct, CLASS_NAMES, STRUCT_NAMES) {
    if (VARIABLE_NAMES[chunk]) {
      if (tokens) {
        module.exports.makeToken(undefined, chunk, tokens, 'IDENTIFIER', chunk);
      }
      return true;
    } else if (lastToken && (lastToken.type === 'DECLARATION_KEYWORD' ||
      lastToken.value === 'for' ||
      
      // special condition for multiple variables of the same type declared on a single line
      (lastToken.value === ',' && VARIABLE_NAMES[tokens[tokens.length -2].value]) ||

        // special conditions to handle for-in loops that iterate over dictionaries
      (lastToken.value === '(' && tokens[tokens.length - 2].value === 'for') ||
      (lastToken.value === ',' && tokens[tokens.length - 3].value) === '(' &&
      tokens[tokens.length - 4].value === 'for' || (insideFunction.length && insideFunction[insideFunction.length - 1].insideParams === true && lastToken.value !== '='))) {
      if (tokens) {
        module.exports.makeToken(undefined, chunk, tokens, 'IDENTIFIER', chunk);
      }
      VARIABLE_NAMES[chunk] = true;
      
      // special conditions to handle identifiers for classes and structs
      if (tokens[tokens.length - 2].value === 'class') {
        var temp = {};
        temp.status = true;
        temp.curly = 0;
        insideClass.push(temp);
        CLASS_NAMES[chunk] = true;
      }
      if (tokens[tokens.length - 2].value === 'struct') {
        var temp = {};
        temp.status = true;
        temp.curly = 0;
        insideStruct.push(temp);
        STRUCT_NAMES[chunk] = true;
      }
      return true;
    }
    return false;
  },

  determineCollectionType: function(collectionInformation, tokens, cb) {
    if (tokens[tokens.length - 1].value === ':') {
      tokens[collectionInformation[collectionInformation.length - 1].location].type = 'DICTIONARY_START';
      collectionInformation[collectionInformation.length - 1].type = 'DICTIONARY_END';
    } else {
      collectionInformation[collectionInformation.length - 1].type  = 'ARRAY_END';
    }
    if (cb) {
      cb();
    }
  },

  handleEndOfFile: function(col, tokens) {
    if (col === undefined) module.exports.makeToken(undefined, undefined, tokens, 'TERMINATOR', 'EOF');
  }

};

var lexer     = require("./lexer");
var deepEqual = require("./helperFunctions").deepEqual;
var diff      = require("./helperFunctions").diff;

var swiftCode = String.raw`func addTwoInts(a: Int, b: Int) -> Int {
                                return a+b
                            }

                            var mathFunction: (Int, Int) -> Int = addTwoInts

                            print(mathFunction(2,3))`;


var swiftCodeAnswers = [
        { type: 'DECLARATION_KEYWORD', value: 'func' },
        { type: 'IDENTIFIER', value: 'addTwoInts' },
        { type: 'PARAMS_START', value: '(' },
        { type: 'IDENTIFIER', value: 'a' },
        { type: 'PUNCTUATION', value: ':' },
        { type: 'TYPE_NUMBER', value: 'Int' },
        { type: 'PUNCTUATION', value: ',' },
        { type: 'IDENTIFIER', value: 'b' },
        { type: 'PUNCTUATION', value: ':' },
        { type: 'TYPE_NUMBER', value: 'Int' },
        { type: 'PARAMS_END', value: ')' },
        { type: 'RETURN_ARROW', value: '->' },
        { type: 'TYPE_NUMBER', value: 'Int' },
        { type: 'STATEMENTS_START', value: '{' },
        { type: 'TERMINATOR', value: '\\n' },

        { type: 'STATEMENT_KEYWORD', value: 'return' },
        { type: 'IDENTIFIER', value: 'a' },
        { type: 'OPERATOR', value: '+' },
        { type: 'IDENTIFIER', value: 'b' },
        { type: 'TERMINATOR', value: '\\n' },

        { type: 'STATEMENTS_END', value: '}' },
        { type: 'TERMINATOR', value: '\\n' },
        { type: 'TERMINATOR', value: '\\n' },

        { type: 'DECLARATION_KEYWORD', value: 'var' },
        { type: 'IDENTIFIER', value: 'mathFunction' },
        { type: 'PUNCTUATION', value: ':' },
        { type: 'PARAMS_START', value: '(' }, 
        { type: 'TYPE_NUMBER', value: 'Int' },
        { type: 'PUNCTUATION', value: ',' },
        { type: 'TYPE_NUMBER', value: 'Int' },
        { type: 'PARAMS_END', value: ')' }, 
        { type: 'RETURN_ARROW', value: '->' }, 
        { type: 'TYPE_NUMBER', value: 'Int' },
        { type: 'OPERATOR', value: '=' },
        { type: 'IDENTIFIER', value: 'addTwoInts' }, //Need to go backward frmo here to var keyword and modify accordingly
        { type: 'TERMINATOR', value: '\\n' },
        { type: 'TERMINATOR', value: '\\n' },

        { type: 'NATIVE_METHOD', value: 'print' },
        { type: 'INVOCATION_START', value: '(' },
        { type: 'IDENTIFIER', value: 'mathFunction' },
        { type: 'TUPLE_START', value: '(' },
        { type: 'NUMBER', value: '2' },
        { type: 'PUNCTUATION', value: ',' },
        { type: 'NUMBER', value: '3' },
        { type: 'TUPLE_END', value: ')' },
        { type: 'INVOCATION_END', value: ')' },
        { type: 'TERMINATOR', value: 'EOF' }
        ];

var ans          = lexer(swiftCode);
var i            = 0;
var mapped       = ans.map(function(obj){
    obj['index'] = i;
    i++;
    return obj;
});
console.log(ans);
console.log(diff(lexer(swiftCode),swiftCodeAnswers));
console.log(deepEqual(lexer(swiftCode),swiftCodeAnswers));

it('should handle functions that return functions which are composed of nested functions', function () {
      input = String.raw`func makeIncrementer() -> ((Int) -> Int) {
                                func addOne(number: Int) -> Int {
                                    func anon(n: Int) -> Int {
                                        return 1 + n
                                    }
                                    return anon(number)
                                }
                                return addOne
                            }`;
      output = [ 
          { type: 'DECLARATION_KEYWORD', value: 'func' },
          { type: 'IDENTIFIER', value: 'makeIncrementer' },
          { type: 'PARAMS_START', value: '(' },
          { type: 'PARAMS_END', value: ')' },
          { type: 'RETURN_ARROW', value: '->' },
          { type: 'PUNCTUATION', value: '(' },
          { type: 'PARAMS_START', value: '(' },
          { type: 'TYPE_NUMBER', value: 'Int' },
          { type: 'PARAMS_END', value: ')' },
          { type: 'RETURN_ARROW', value: '->' },
          { type: 'TYPE_NUMBER', value: 'Int' },
          { type: 'PUNCTUATION', value: ')' },
          { type: 'STATEMENTS_START', value: '{' },
          { type: 'TERMINATOR', value: '\\n' },

          { type: 'DECLARATION_KEYWORD', value: 'func' },
          { type: 'IDENTIFIER', value: 'addOne' },
          { type: 'PARAMS_START', value: '(' },
          { type: 'IDENTIFIER', value: 'number' },
          { type: 'PUNCTUATION', value: ':' },
          { type: 'TYPE_NUMBER', value: 'Int' },
          { type: 'PARAMS_END', value: ')' },
          { type: 'RETURN_ARROW', value: '->' },
          { type: 'TYPE_NUMBER', value: 'Int' },
          { type: 'STATEMENTS_START', value: '{' },
          { type: 'TERMINATOR', value: '\\n' },

          { type: 'DECLARATION_KEYWORD', value: 'func' },
          { type: 'IDENTIFIER', value: 'anon' },
          { type: 'PARAMS_START', value: '(' },
          { type: 'IDENTIFIER', value: 'n' },
          { type: 'PUNCTUATION', value: ':' },
          { type: 'TYPE_NUMBER', value: 'Int' },
          { type: 'PARAMS_END', value: ')' },
          { type: 'RETURN_ARROW', value: '->' },
          { type: 'TYPE_NUMBER', value: 'Int' },
          { type: 'STATEMENTS_START', value: '{' },
          { type: 'TERMINATOR', value: '\\n' },

          { type: 'STATEMENT_KEYWORD', value: 'return' },
          { type: 'NUMBER', value: '1' },
          { type: 'OPERATOR', value: '+' },
          { type: 'IDENTIFIER', value: 'n' },
          { type: 'TERMINATOR', value: '\\n' },

          { type: 'STATEMENTS_END', value: '}' },
          { type: 'TERMINATOR', value: '\\n' },

          { type: 'STATEMENT_KEYWORD', value: 'return' },
          { type: 'IDENTIFIER', value: 'anon' },
          { type: 'INVOCATION_START', value: '(' },
          { type: 'IDENTIFIER', value: 'number' },
          { type: 'INVOCATION_END', value: ')' },
          { type: 'TERMINATOR', value: '\\n' },

          { type: 'STATEMENTS_END', value: '}' },
          { type: 'TERMINATOR', value: '\\n' },

          { type: 'STATEMENT_KEYWORD', value: 'return' },
          { type: 'IDENTIFIER', value: 'addOne' },
          { type: 'TERMINATOR', value: '\\n' },
          
          { type: 'STATEMENTS_END', value: '}' },
          { type: 'TERMINATOR', value: 'EOF' } 
          ];
      expect(lexer(input)).to.deep.equal(output);
    });