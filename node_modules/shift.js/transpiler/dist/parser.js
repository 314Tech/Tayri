var originalScope = require('./originalScope');
var tokenTypes = require('./tokenTypes');

/**
 * Look forward one token in the collection
 */
var advance = function(state, id) {

  var a, o, t, v;

  if (id && state.token.id !== id) {
    state.token.error("Expected '" + id + "'.");
  }

  if (state.index >= state.tokens.length) {
    state.token = state.symbolTable["(end)"];
    return state;
  }

  t = state.tokens[state.index];
  state.index += 1;
  v = t.value;
  a = t.type;

  if (tokenTypes.noun.hasItem(a)) {
    if (a === "DECLARATION_KEYWORD" && (v === "var" || v === "let")) {
      v = "var";
    }
    o = state.scope.find(v, state.symbolTable);
  } else if (tokenTypes.collectionStart.hasItem(a)) {

    if(a === "ARRAY_START") {
      v = '[';
      o = state.symbolTable['['];
    } else {
      v = '{';
      o = state.symbolTable['{'];
    }

    if (!o) {
      t.error("Unknown operator.");
    }
  } else if (tokenTypes.terminator.hasItem(a) || tokenTypes.verb.hasItem(a)) {
    o = state.symbolTable[v];
    if (!o) {
      t.error("Unknown operator.");
    }
  } else if (tokenTypes.primitive.hasItem(a)) {
    o = state.symbolTable["(literal)"];
    a = "literal";
  } else if(tokenTypes.comment.hasItem(a)) {
    //
  } else {
    t.error("Unexpected token.");
  }

  state.token = Object.create(o);
  state.token.value = v;
  state.token.type = a;

  return state;

};

module.exports = advance;
var expression = require('./expression');
var infixr = require('./infixr');

var assignment = function(state, id) {
  return infixr(state, id, 10, function(left) {
    if(left.id) {
      if (left.id !== "+=" && left.id !== "." && left.id !== "[" && left.type !== "name" && left.id !== "(name)") {
        left.error("Bad lvalue.");
      }
    } else if(left.type) {
      if(left.type !== "IDENTIFIER") {
        left.error("Bad lvalue.");
      }
    }
    left.type = "Identifier";
    left.name = left.value;;
    delete left.value;
    this.left = left;
    this.right = expression(state, 9);
    this.assignment = true;
    this.operator = this.value;
    this.type = "AssignmentExpression";
    delete this.value;
    return this;
  });
};

module.exports = assignment;

var advance = require('./advance');

var block = function(state) {
  var t = state.token;
  state = advance(state, "{");
  if(state.token.value === "\\n") {
    state = advance(state);
  }
  var stdReturnVal = t.std();
  var blockStmtChildNode;

  /* Logic as to whether statement node needs a parent node wrapper */
  if(Array.isArray(stdReturnVal)) {
    blockStmtChildNode = stdReturnVal;
  } else if(["IfStatement", "ReturnStatement", "ForStatement"].hasItem(stdReturnVal.type)) {
    blockStmtChildNode = stdReturnVal;
  } else if(stdReturnVal.type !== "ExpressionStatement") {
    blockStmtChildNode = {
      type: 'ExpressionStatement',
      expression: stdReturnVal
    };
  }
  else {
    blockStmtChildNode = stdReturnVal;
  }

  var blockStmt = { type: 'BlockStatement' };
  blockStmt.body = (Array.isArray(blockStmtChildNode)) ? blockStmtChildNode : [blockStmtChildNode];

  return blockStmt;
};

module.exports = block;
var symbol = require('./symbol');
var originalSymbol = require('./originalSymbol');

var constant = function(state, s, v) {
  var x = symbol(state, originalSymbol, s);
  x.nud = function() {
    state.scope.reserve(this);
    this.value = symbolTable[this.id].value;
    this.type = "literal";//TODO "literal" -> "Literal"
    return this;
  };
  x.value = v;
  return x;
};

module.exports = constant;
var util = require('util');
var diff = require('deep-diff').diff;
var helpers = require('./helperFunctions.js');
var advance = require('./advance');
var newScope = require('./newScope');
var originalScope = require('./originalScope');
var originalSymbol = require('./originalSymbol');
var symbol = require('./symbol');
var block = require('./block');
var expression = require('./expression');
var infix = require('./infix');
var infixr = require('./infixr');
var assignment = require('./assignment');
var prefix = require('./prefix');
var stmt = require('./stmt');
var statements = require('./statements');
var statement = require('./statement');

var declarations = {
  symbols: function(state) {
    symbol(state, originalSymbol, "EOF");
    symbol(state, originalSymbol, "\n");
    symbol(state, originalSymbol, "\\n");
    symbol(state, originalSymbol, "(end)");
    symbol(state, originalSymbol, "(name)").nud = helpers.itself;
    symbol(state, originalSymbol, ":");
    symbol(state, originalSymbol, ";");
    symbol(state, originalSymbol, ")");
    symbol(state, originalSymbol, "]");
    symbol(state, originalSymbol, "}");
    symbol(state, originalSymbol, ",");
    symbol(state, originalSymbol, "else");
    symbol(state, originalSymbol, "(literal)").nud = helpers.itself;
    symbol(state, originalSymbol, "this").nud = function() {
      state.scope.reserve(this);
      this.type = "this";
      return this;
    };
  },

  assignments: function(state) {
    assignment(state, "=");
    assignment(state, "+=");
    assignment(state, "-=");
    assignment(state, "*=");
    assignment(state, "/=");
  },

  infixes: function(state) {
    infix(state, "?", 20, function(left) {
      this.type = "ConditionalExpression";
      if(left.type === "IDENTIFIER") {
        left.type = "Identifier";
        left.name = left.value;
        delete left.value;
      }
      this.test = left;
      this.consequent = expression(state, 0);
      state = advance(state, ":");
      this.alternate = expression(state, 0);
      delete this.value;
      return this;
    });

    infixr(state, "&&", 30);
    infixr(state, "||", 30);
    infixr(state, "===", 40);
    infixr(state, "==", 40);
    infixr(state, "!==", 40);
    infixr(state, "!=", 40);
    infixr(state, "<", 40);
    infixr(state, "<=", 40);
    infixr(state, ">", 40);
    infixr(state, ">=", 40);
    infix(state, "+", 50);
    infix(state, "-", 50);
    infix(state, "*", 60);
    infix(state, "/", 60);
    infix(state, "%", 60);

    infix(state, ".", 80, function(left) {
      //this.first = left;//TODO other change
      this.type = "MemberExpression";
      this.computed = false;
      this.object = left;// object: { value: 'Array', type: 'IDENTIFIER' },
      if(this.object.type === "IDENTIFIER") {
        this.object.type = "Identifier";
        this.object.name = this.object.value;
        delete this.object.value;
      } else if(this.object.type === "MemberExpression") {
        delete this.value;
      }

      // want  object: { type: 'Identifier', name: 'Array' },
      if (state.token.type !== "IDENTIFIER") {
        state.token.error("Expected a property name.");
      }
      if(state.token.type === "IDENTIFIER") {
        state.token.type = "Identifier";
        state.token.name = state.token.value;
        delete state.token.value;
      }
      delete this.name;
      delete this.value;//'.'
      this.property = state.token;
      state = advance(state);
      return this;
    });

    infix(state, "[", 80, function(left) {
      this.type = "MemberExpression";
      this.computed = true;
      if(left.type === 'IDENTIFIER'){
        left.name = left.value;
        left.type = "Identifier";
        delete left.value;
      }
      this.object = left;
      this.property = expression(state, 0);
      delete this.value;
      state = advance(state, "]");
      return this;
    });

    infix(state, "(", 80, function(left) {
      var a = [], parentParentNode;
      if (left.id === "." || left.id === "[") {
        this.type = "MemberExpression";
        this.computed = false;
        delete this.value;
        this.object = left.object;

        //this.object.name = this.object.value;//TODO Add logic, sometimes necessary
        delete this.object.value;
        //this.object.type = "Identifier";//TODO Needs to go (at least in this case)
        this.property = left.property;
        if(!this.property.name) {
          this.property.name = this.property.value;
        }
        delete this.property.value;
        this.property.type = "Identifier";
        delete this.property.arity;

        parentParentNode = {
          type: 'ExpressionStatement',
          expression: {
            type: 'CallExpression',
            callee: this,
            arguments: a
          }
        };
      } else {
        this.object = left;
        this.arguments = a;
        if ((left.arity !== "unary" || left.id !== "function") &&
          left.type !== "IDENTIFIER" && left.id !== "(" &&
          left.id !== "&&" && left.id !== "||" && left.id !== "?") {
          left.error("Expected a variable name.");
        }

        parentParentNode = this;

      }

      /*TODO add logic checking for invocation parameter naming, ex (day: "Tuesday")*/
      // Are swift params order dependent??

      if (state.token.id !== ")") {
        while (true) {

          var lookAheadOne = state.tokens[state.index];
          if(lookAheadOne.value === ":") {
            state = advance(state);
            state = advance(state);
          }

          a.push(expression(state, 0));

          if (state.token.id !== ",") {
            break;
          }
          state = advance(state, ",");
        }
      }
      state = advance(state, ")");
      return parentParentNode;
    });
  },

  prefixes: function(state) {
    prefix(state, "+");
    prefix(state, "!");
    prefix(state, "++");
    prefix(state, "--");
    prefix(state, "-");
    prefix(state, "typeof");

    prefix(state, "(", function() {
      var e = expression(state, 0, true);
      state = advance(state, ")");
      return e;
    });

    prefix(state, "func", function() {
      var a = [];
      state.scope = newScope(state, originalScope);
      if (state.token.type === "IDENTIFIER") {
        state.scope.define(state, state.token);
        this.name = state.token.value;
        state = advance(state);
      }
      state = advance(state, "(");
      if (state.token.id !== ")") {
        while (true) {
          if(state.token.value === "var") {
            state = advance(state);
          }
          if (state.token.type !== "IDENTIFIER") {
            state.token.error("Expected a parameter name.");
          }
          state.scope.define(state, state.token);
          state.token.type = "Identifier";
          state.token.name = state.token.value;
          delete state.token.value;

          a.push(state.token);
          state = advance(state);
          if (state.token.id === ":") {

            while (true) {
              if (state.token.value !== ',' && state.token.value !== '{') {
                state = advance(state);
              } else {
                break;
              }
            }

            //state = advance(state);
            //state = advance(state);

          }
          if (state.token.id !== ",") {
            break;
          }
          state = advance(state, ",");
        }
      }

      if(state.token.value === ")") {
        state = advance(state, ")");
      }
      if(state.token.value === "->") {
        state = advance(state);
        while (true) {
          if (state.token.value !== '{') {
            state = advance(state);
          } else {
            break;
          }
        }
      }

      state = advance(state, "{");

      while(true) {
        if(state.token.value === "\\n") {
          state = advance(state);
        } else {
          break;
        }
      }

      /* TODO Hacky solution to 'let a = a + 1' when a has already been defined as a parameter to function signature. */

      var tmpLookAhead = state.tokens[state.index];
      if(state.token.value === "var") {
        for(var p=0; p<a.length; p++) {
          var param = a[p];
          var paramIdentity = param.name;
          if(tmpLookAhead.value === paramIdentity) {
            //TODO delete item from scope so it can be re-added
            state.scope.delete(state, tmpLookAhead);
            // remove var token from tokens array
            state.tokens.splice(state.index - 1, 1);

            var t = state.tokens[state.index - 1];
            var tmpVar = state.scope.find(t.value, state.symbolTable);
            var tmpSymb = Object.create(tmpVar);
            tmpSymb.value = t.value;
            tmpSymb.type = t.type;
            state.token = tmpSymb;
          }
        }
      }

      var fnBody = statements(state);

      while(true) {
        if(state.token.value === "\\n") {
          state = advance(state);
        } else {
          break;
        }
      }

      state = advance(state, "}");

      var fnBodyArray = Array.isArray(fnBody) ? fnBody : [fnBody];

      if(fnBodyArray.length>0) {
        for(var w=0; w<fnBodyArray.length; w++) {
          var bodyStmt = fnBodyArray[w];
          if(bodyStmt.type === "CallExpression") {
            var expressionStmtWrapper = {
              type: 'ExpressionStatement',
              expression: bodyStmt
            };
            fnBodyArray[w] = expressionStmtWrapper;
          }
        }
      }

      this.type = "FunctionDeclaration";
      delete this.value;
      this.id = {
        type: "Identifier",
        name: this.name
      };
      delete this.name;
      this.params = a;
      this.defaults = [];
      this.body = {
        type: 'BlockStatement',
        body: fnBodyArray
      };
      this.generator = false;
      this.expression = false;
      state.scope.pop();
      return this;
    });

    prefix(state, "[", function() {
      var a = [];
      if (state.token.id !== "]") {
        while (true) {
          a.push(expression(state, 0));
          if (state.token.id !== ",") {
            break;
          }
          state = advance(state, ",");
        }
      }
      state = advance(state, "]");
      this.type = "ArrayExpression";
      delete this.value;
      delete this.raw;
      this.elements = a;
      return this;
    });

    prefix(state, "{", function() {
      var a = [], n, v;

      while(true) {
        if(state.token.value === "\\n") {
          state = advance(state);
        }
        else {
          break;
        }
      }

      /**
       * Currently only handles collections
       * TODO Extend to also include function bodies?
       */

      var tmpLookAhead = state.tokens[state.index];
      if(tmpLookAhead.type === "DICTIONARY_END") {
        state = advance(state);
        this.type = "ObjectExpression";
        this.properties = [];
        delete this.value;
        delete this.raw;
        return this;
      }
      if(tmpLookAhead.value === ",") {
        // Handle Tuples w/out keys
        var a = [];
        if (state.token.id !== "]") {
          while (true) {
            a.push(expression(state, 0));
            if (state.token.id !== ",") {
              break;
            }
            state = advance(state, ",");
          }
        }
        state = advance(state, ")");
        this.type = "ObjectExpression";
        delete this.value;
        delete this.raw;
        this.properties = [];
        for(var m=0; m<a.length; m++) {
          var currentValue = a[m];
          var kvMap = {};
          kvMap.type = "Property";
          kvMap.computed = false;
          kvMap.kind = 'init';
          kvMap.method = false;
          kvMap.shorthand = false;
          kvMap.key = {};
          kvMap.key.type = "Literal";
          var keyIndex = this.properties.length;
          kvMap.key.value = keyIndex;
          kvMap.key.raw = keyIndex.toString();
          kvMap.value = currentValue;
          this.properties.push(kvMap);
        }
        return this;
      }
      /* Get all things in dictionary */
      if ((state.token.id !== "]" &&  state.token.id !== ")") && tmpLookAhead.value !== ",") {
        while (true) {
          n = state.token;
          /* if  */
          if (n.type !== "IDENTIFIER" && n.type !== "literal" && n.type !== "TUPLE_ELEMENT_NAME") {
            state.token.error("Bad property name.");
          }
          state = advance(state);
          state = advance(state, ":");
          v = expression(state, 0);

          var kvMap = {};
          kvMap.type = "Property";
          kvMap.computed = false;
          kvMap.kind = 'init';
          kvMap.method = false;
          kvMap.shorthand = false;

          if (n.type === "literal" && helpers.isNum(n.value)) {
            n.type = "Literal";
            n.raw = n.value;
            if (n.value.indexOf('.')) {
              n.value = parseFloat(n.value);
            } else {
              n.value = parseInt(n.value);
            }
          } else if (n.type === "literal" && helpers.isBool(n.value)) {
            n.type = "Identifier";
            n.name = n.value;
            delete n.raw;
            delete n.value;
          } else if (n.type === "literal") {
            // This is for type string
            n.type = "Literal";
            n.raw = '"' + n.value + '"';
          } else if(n.type === "TUPLE_ELEMENT_NAME") {
            n.type = "Identifier";
            n.name = n.value;
            delete n.value;
          }
          kvMap.key = n;
          kvMap.value = v;

          /* a.push(v); */
          a.push(kvMap);

          if (state.token.id !== ",") {
            break;
          }

          while(true) {
            if(state.token.value === "\\n") {
              state = advance(state);
            }
            else {
              break;
            }
          }

          state = advance(state, ",");

          while(true) {
            if(state.token.value === "\\n") {
              state = advance(state);
            }
            else {
              break;
            }
          }

          if(state.token.type === "DICTIONARY_END") {
            break;
          }
        }
      }

      try {
        state = advance(state, "]");//TODO just one here
      } catch(e) {
        state = advance(state, ")");
      }

      this.type = "unary";
      delete this.value;
      this.type = "ObjectExpression";
      this.properties = a;
      return this;
    });
  },

  stmts: function(state) {
    stmt(state, "{", function() {
      state.scope = newScope(state, originalScope);
      var a = statements(state);
      state = advance(state, "}");
      state.scope.pop();
      return a;
    });

    stmt(state, "var", function() {
      var a = [], n, t;
      while (true) {
        n = state.token;
        if (n.type !== "IDENTIFIER") {
          n.error("Expected a new variable identifier.");
        } else {
          n.type = "Identifier";
          n.name = n.value;
        }

        state.scope.define(state, n);
        delete n.value;

        state = advance(state);

        /* Type Declarations */
        if(state.token.id === ":") {
          state = advance(state, ":");
          if(state.token.type === "TYPE_STRING") {
            state = advance(state);
          } else if(state.token.type === "TYPE_NUMBER") {
            state = advance(state);
          } else if(state.token.type === "TYPE_BOOLEAN") {
            state = advance(state);
          }
        }

        /* Assignment to a variable declaration */
        if (state.token.id === "=") {
          t = state.token;
          state = advance(state, "=");

          t.type = 'VariableDeclaration';
          t.kind = 'var';
          t.declarations = [{
            type: 'VariableDeclarator',
            id: {},
            init: {}
          }];

          t.declarations[0].id = n; //TODO FIX
          t.declarations[0].init = expression(state, 0);
          delete t.value;

          a.push(t);
        }
        /* Uninitialized variable declaration */
        else if ([";", ")"].hasItem(state.token.id)) {
          t = state.token;
          t.type = 'VariableDeclaration';
          t.kind = 'var';
          t.declarations = [{
            type: 'VariableDeclarator',
            id: {},
            init: {}
          }];
          t.declarations[0].id = n;
          t.declarations[0].init = null;
          delete t.value;

          a.push(t);
          if(state.token.id === ";") {
            state = advance(state);
          }
          break;

        } else if(state.token.type === "TERMINATOR") {
          state = advance(state);
        }
        //TODO maybe check for newlines here

        if(state.token.id === ";") {
          state = advance(state);
        }

        if (state.token.id !== ",") {
          break;
        }
        state = advance(state, ",");
      }
      //TODO outside of the while loop

      if([";", "var", "if", "while", "repeat", "for", "++", "--"].hasItem(state.token.value)) {
        return a.length === 0 ? null : a.length === 1 ? a[0] : a;
      } else if(state.token.type === "IDENTIFIER") {
        return a.length === 0 ? null : a.length === 1 ? a[0] : a;
      } else if(state.token.value === "\\n") {
        return a.length === 0 ? null : a.length === 1 ? a[0] : a;
      }

      state = advance(state);

      if(state.token.value === "var") {
        return a.length === 0 ? null : a.length === 1 ? a[0] : a;
      }
      //if(state.token.value === "\\n") {
      //  state = advance(state);
      //}
      while(true) {
        if(state.token.value === "\\n") {
          state = advance(state);
        }
        else {
          break;
        }
      }
      return a.length === 0 ? null : a.length === 1 ? a[0] : a;
    });

    stmt(state, "if", function() {

      state = advance(state, "(");
      this.test = expression(state, 0);
      if(this.test.type === "ExpressionStatement") {
        this.test = this.test.expression;
      }
      state = advance(state, ")");

      this.consequent = block(state);

      /* block directly followed by else or else if statement? */
      if (state.token.id === "else") {
        state.scope.reserve(state.token);
        state = advance(state, "else");
        this.alternate = state.token.id === "if" ? statement(state) : block(state);
      } else {
        this.alternate = null;
      }

      this.type = "IfStatement";
      delete this.value;
      return this;
    });

    stmt(state, "return", function() {

      if (state.token.id !== ";") {
        this.argument = expression(state, 0);
      }

      while(true) {
        if(state.token.value === "\\n") {
          state = advance(state);
        } else {
          break;
        }
      }

      if(state.token.id === ";") {
        state = advance(state, ";");
      }

      while(true) {
        if(state.token.value === "\\n") {
          state = advance(state);
        } else {
          break;
        }
      }

      if (state.token.id !== "}") {
        state.token.error("Unreachable statement.");
      }

      this.type = "ReturnStatement";
      delete this.value;

      if(this.argument.type === "ExpressionStatement" && this.argument.expression.type === "CallExpression") {
        this.argument = this.argument.expression;
      }

      return this;
    });

    stmt(state, "break", function() {
      state = advance(state, ";");
      if (state.token.id !== "}") {
        state.token.error("Unreachable statement.");
      }
      return this;
    });

    stmt(state, "while", function() {
      this.type = "WhileStatement";
      if(state.tokens[state.index-1].value === "(") {
        state = advance(state, "(");
        this.test = expression(state, 0);
        state = advance(state, ")");
      } else {
        this.test = expression(state, 0);
      }
      this.body = block(state);
      delete this.value;
      return this;
    });

    stmt(state, "for", function() {
      this.type = "ForStatement";

      //TODO Refactor For Statements

      /* for( var identifier) 'in' identifier { .. } */
      /* to distinguish this if from conventional for-loop below */
      if(state.tokens[state.index-1].value === "(" && state.tokens[state.index+2].value === ")") {

        this.type = "ForInStatement"
        if (state.token.value === "(") {
          state = advance(state);
        }
        this.left = statements(state, 1, true);
        //state.token.value === "in"
        state = advance(state);
        this.each = false;
        this.right = {};
        this.right.type = "Identifier";
        this.right.name = state.token.value;
        state = advance(state);
      }
      /* for( var identifier..;exp;exp) { } */
      else if(state.tokens[state.index-1].value === "(") {
        state = advance(state, "(");
        this.init = statements(state, 1);
        this.test = expression(state, 0);
        if(state.token.value === ";") {
          state = advance(state, ";");
        }
        this.update = expression(state, 0);
        state = advance(state, ")");
      }
      /* for KEYWORD_DECLARATION IDENTIFIER "IN" IDENTIFIER { } */
      else if(state.tokens[state.index-1].type === "IDENTIFIER" && state.tokens[state.index+1].type === "IDENTIFIER") {

        this.type = "ForInStatement";

        /* Splice in a var keyword */
        var symbVar = state.symbolTable["var"];
        var tkVar = Object.create(symbVar);
        tkVar.value = "var";
        tkVar.type = "DECLARATION_KEYWORD";
        state.tokens.splice(state.index-1, 0, tkVar);
        state.token = state.tokens[state.index-1];

        /* Splice in an end parens */
        var symbEndParen = state.symbolTable[")"];
        var tkEndParen = Object.create(symbEndParen);
        tkEndParen.value = ")";
        tkEndParen.type = "PUNCTUATION";
        state.tokens.splice(state.index+1, 0, tkEndParen);

        this.left = statements(state, 1, true);
        state = advance(state);
        this.each = false;
        this.right = {};
        this.right.type = "Identifier";
        this.right.name = state.token.value;
        state = advance(state);

      } else {

        this.init = statements(state, 1);
        this.test = expression(state, 0);
        if(state.token.value === ";") {
          state = advance(state, ";");
        }
        this.update = expression(state, 0);
      }

      this.body = block(state);
      delete this.value;
      return this;
    });

    stmt(state, "repeat", function() {
      this.type = "DoWhileStatement";
      this.body = block(state);
      if(state.token.value === 'while') {
        state = advance(state);
      }
      if(state.tokens[state.index-1].value === "(") {
        state = advance(state, "(");
        this.test = expression(state, 0);
        state = advance(state, ")");
      } else {
        this.test = expression(state, 0);
      }
      delete this.value;
      if(state.token.value === ";") {
        state = advance(state);
      }
      return this;
    });

  },
  constants: function(state) {
    //constant(state, "true", true);
    //constant(state, "false", false);
    //constant(state, "null", null);
    //constant(state, "pi", 3.141592653589793);
    //constant(state, "Object", {});
    //constant(state, "Array", []);
  }


};

module.exports = declarations;
var advance = require('./advance');
var helpers = require('./helperFunctions');

/**
 * Begin parsing an expression phrase from the current token
 * Calls itself recursively depending on the context.
 **/
var expression = function(state, rbp, dontWrapBinExpNodeInExpStmtBool) {

  var left;
  var t = state.token;
  state = advance(state);
  left = t.nud();



  if (t.value === "++" || t.value === "--") {
    /*Pre-fix operator*/
    left = t;

    if(state.token.value !== "}" && state.token.value !== "==") {
      state = advance(state);
    }
  } else if (state.token.value === "++" || state.token.value === "--") {
    /*Post-fix operators*/
    if(state.token.value === "++") {
      left.type = "Identifier";
      left.name = left.value;
      delete left.value;
      state = advance(state);
      var tmpParentNode = {
        "type": "UpdateExpression",
        "operator": "++",
        "prefix": false,
        "argument": left,
        assignment: true
      };
      left = tmpParentNode;
    } else {
      left.type = "Identifier";
      left.name = left.value;
      delete left.value;
      state = advance(state);
      var tmpParentNode = {
        "type": "UpdateExpression",
        "operator": "--",
        "prefix": false,
        "argument": left
      };
      left = tmpParentNode;
    }
  } else if (t.operator === "+") {
    delete t.value;
    state.token.name = state.token.value;
    state.token.type = "Identifier";
    delete state.token.value;
    t.argument = state.token;
  }

  /**
   * Logic to handle the recursive case
   */
  while (rbp < state.token.lbp) {
    t = state.token;
    state = advance(state);
    left = t.led(left);//assignments
  }


  if (left.type === "IDENTIFIER") {
    left.name = left.value;
    left.type = "Identifier";
    delete left.value;
  }
  else if (left.type === "literal" && helpers.isNum(left.value)) {
    left.type = "Literal";
    left.raw = left.value;
    if (left.value.indexOf('.')) {
      left.value = parseFloat(left.value);
    } else {
      left.value = parseInt(left.value);
    }
  }
  else if (left.type === "literal" && helpers.isBool(left.value)) {
    left.type = "Literal";
    left.raw = t.value;
    left.value = t.value === "true";
  }
  else if (left.type === "literal") {
    left.type = "Literal";
    left.raw = '"' + t.value + '"';
  }
  else if (left.operator === "=") {
    var expStmt = {};
    expStmt.type = "ExpressionStatement";

    if(left.left.object && left.left.property) {
      left.left.type = "MemberExpression";
      delete left.left.name;
    }
    expStmt.expression = left;
    left = expStmt;
    left.assignment = true;
  } else if (left.operator === "==") {

    if(!dontWrapBinExpNodeInExpStmtBool) {
      var expressionStmtNode = { type: 'ExpressionStatement' };
      expressionStmtNode.expression = left;
      left = expressionStmtNode;
    }
  } else if (left.operator === "===") {
    //TODO
  } else if (t.value === ".") {
    state = advance(state);
  }
  else if (left.type === "INVOCATION_START") {
    delete left.value;
    left.type = "CallExpression";
    left.callee = left.object;
    delete left.object;
    if(left.callee.type === "IDENTIFIER") {
      left.callee.type = "Identifier";
      left.callee.name = left.callee.value;
      delete left.callee.value;
    }
  } else if(left.type === "ExpressionStatement") {
    left = left.expression;
  }

  return left;
};

module.exports = expression;
/**
 *
 */

var helpers = {
  deletePropertyIfExists : function (node, propertyArray) {
    if(node !== null) {
      for (var i = 0; i < propertyArray.length; i++) {
        var prop = propertyArray[i];
        var hasProp = node.hasOwnProperty(prop);
        if (hasProp) {
          delete node[prop];
        }
      }
    }
  },
  /**
   * Recursively walk a tree and apply a callback on each node
   */
  traverse: function (node, func) {
    var self = this;
    func(node);
    if(node !== null) {
      if (node.scope) {
        delete node.scope;
      }
      for (var key in node) {
        if (node.hasOwnProperty(key)) {
          var child = node[key];
          if (typeof child === 'object' && child !== null) {
            if (Array.isArray(child)) {
              child.forEach(function(node) {
                self.traverse(node, func);
              });
            } else {
              self.traverse(child, func);
            }
          }
        }
      }
    }
  },
  /**
   * Make initial pass through input token stream removing ambiguity of certain token permutations to the parser.
   * Example 1: Characters of pre- and post-fix increment & decrement
   *        operators are lexed independently as separate operators.
   * Example 2: Swift, but not Javascript, allows for dynamic property
   *        look-ups within literal declarations of collections.
   **/
  cleanUpTokenStream: function(input) {
    for (var i = 0; i < input.length; i++) {
      if (input[i].type === "STRING_INTERPOLATION_START" || input[i].type === "STRING_INTERPOLATION_END") {
        input[i].type = "OPERATOR";
        input[i].value = "+";
      }
      if (input[i].value === "!") {
        if (input[i + 1].value === "=") {
          if (input[i + 2].value === "=") {
            input.splice(i + 1, 2);
            input[i].value = "!==";
            return input;
          } else {
            input.splice(i + 1, 1);
            input[i].value = "!=";
          }
        }
      }
      if (input[i].value === "=") {
        if (input[i + 1].value === "=") {
          if (input[i + 2].value === "=") {
            input.splice(i + 1, 2);
            input[i].value = "===";
          } else {
            input.splice(i + 1, 1);
            input[i].value = "==";
          }
        }
      }
      if (input[i].value === "+") {
        if (input[i + 1].value === "+") {
          input.splice(i + 1, 1);
          input[i].value = "++";
        }
      }
      if (input[i].value === "-") {
        if (input[i + 1].value === "-") {
          input.splice(i + 1, 1);
          input[i].value = "--";
        }
      }
      if (input[i].value === "|") {
        if (input[i + 1].value === "|") {
          input.splice(i + 1, 1);
          input[i].value = "||";
        }
      }
      if (input[i].value === ">") {
        if (input[i + 1].value === "=") {
          input.splice(i + 1, 1);
          input[i].value = ">=";
        }
      }
      if (input[i].value === "<") {
        if (input[i + 1].value === "=") {
          input.splice(i + 1, 1);
          input[i].value = "<=";
        }
      }
      if (input[i].value === "*") {
        if (input[i + 1].value === "=") {
          input.splice(i + 1, 1);
          input[i].value = "*=";
        }
      }
      if (input[i].value === "/") {
        if (input[i + 1].value === "=") {
          input.splice(i + 1, 1);
          input[i].value = "/=";
        }
      }
      if (input[i].value === "+") {
        if (input[i + 1].value === "=") {
          input.splice(i + 1, 1);
          input[i].value = "+=";
        }
      }
      if (input[i].value === "-") {
        if (input[i + 1].value === "=") {
          input.splice(i + 1, 1);
          input[i].value = "-=";
        }
      }

      /* Remove inline comments */
      if (input[i].type === "COMMENT_START") {
        if (input[i + 1].type === "COMMENT") {
          input.splice(i, 2);
        }
      }
      /* Remove multi-line comments */
      if (input[i].type === "MULTI_LINE_COMMENT_START") {

        for(var j=i; input.length; j++) {
          if (input[j].type === "MULTI_LINE_COMMENT_END") {
            input.splice(i, j - i + 1);
            return input;//TODO BUG BUG if multiple comments
          }
        }
      }

    }
    return input;
  },
  isNum : function(val) {
    return /^\d+.*$/.test(val);
  },
  isBool : function(val) {
    return val === 'true' || val === 'false';
  },
  itself : function() {
    return this;
  }

};

module.exports = helpers;

var symbol = require('./symbol');
var helpers = require('./helperFunctions');
var expression = require('./expression');
var originalSymbol = require('./originalSymbol');

var infix = function(state, id, bp, led) {
  var s = symbol(state, originalSymbol, id, bp);
  s.led = led || function(left) {
      delete this.value;
      this.type = "BinaryExpression";
      this.operator = this.value;
      if(this.operator === "||") {
        this.type = "LogicalExpression";
      }
      if(left.type === "IDENTIFIER") {
        left.type = "Identifier";
        left.name = left.value;
        delete left.value;
      } else if(left.type === "literal" && helpers.isNum(left.value)) {
        left.type = "Literal";
        left.raw = left.value;
        if (left.value.indexOf('.') === -1) {
          left.value = parseFloat(left.value);
        } else {
          left.value = parseInt(left.value);
        }
      } else if (left.type === "literal" && helpers.isBool(left.value)) {
        // TODO
      } else if (left.type === "literal") {
        // Fall-through for type string
        left.type = "Literal";
        left.raw = '"' + left.value + '"';
      }
      this.left = left;
      this.right = expression(state, bp);
      return this;
    };
  return s;
};

module.exports = infix;
var symbol = require('./symbol');
var helpers = require('./helperFunctions');
var expression = require('./expression');
var originalSymbol = require('./originalSymbol');

var infixr = function(state, id, bp, led) {
  var s = symbol(state, originalSymbol, id, bp);
  s.led = led || function(left) {
      delete this.value;
      this.type = "BinaryExpression";
      this.operator = this.value;
      if(this.operator === "||") {
        this.type = "LogicalExpression";
      }
      if(left.type === "IDENTIFIER") {
        left.type = "Identifier";
        left.name = left.value;
        delete left.value;
      } else if(left.type === "literal" && helpers.isNum(left.value)) {
        left.type = "Literal";
        left.raw = left.value;
        if (left.value.indexOf('.') === -1) {
          left.value = parseFloat(left.value);
        } else {
          left.value = parseInt(left.value);
        }
      } else if (left.type === "literal" && helpers.isBool(left.value)) {
        // TODO type boolean
      } else if (left.type === "literal") {
        // Fall-through for type string
        left.type = "Literal";
        left.raw = '"' + left.value + '"';
      }
      this.left = left;
      this.right = expression(state, bp - 1);
      return this;
    };
  return s;
};

module.exports = infixr;
var newScope = function(state, originalScope) {

  var s = state.scope;
  state.scope = Object.create(originalScope);
  state.scope.def = {};
  state.scope.parent = s;
  return state.scope;
};

module.exports = newScope;
var newScope = function(state, originalScope) {

  var s = state.scope;
  state.scope = Object.create(originalScope);
  state.scope.def = {};
  state.scope.parent = s;
  return state.scope;
};

module.exports = newScope;
var helpers = require('./helperFunctions');

var originalScope = {
  define: function(state, n) {
    var scope = state['scope'];
    var t = this.def[n.value];
    if (typeof t === "object") {
      console.log(n.value);
      n.error(t.reserved ? "Already reserved." : "Already defined.");
    }
    this.def[n.value] = n;
    n.reserved = false;
    n.nud = helpers.itself;
    n.led = null;
    n.std = null;
    n.lbp = 0;
    n.scope = scope;
    return n;
  },
  delete: function(state, n) {
    delete this.def[n.value];
  },
  find: function(n, symbolTable) {
    var e = this,
      o;
    while (true) {
      o = e.def[n];
      if (o && typeof o !== 'function') {
        return e.def[n];
      }
      e = e.parent;
      if (!e) {
        o = symbolTable[n];
        return o && typeof o !== 'function' ? o : symbolTable["(name)"];
      }
    }
  },
  pop: function() {
    scope = this.parent;
  },
  reserve: function(n) {
    if (n.type !== "name" || n.reserved) {
      return;
    }
    var t = this.def[n.value];
    if (t) {
      if (t.reserved) {
        return;
      }
      if (t.type === "name") {
        n.error("Already defined.");
      }
    }
    this.def[n.value] = n;
    n.reserved = true;
  }
};

module.exports = originalScope;
var originalSymbol = {
  nud: function() {
    this.error("Undefined.");
  },
  led: function(left) {
    this.error("Missing operator.");
  }
};

module.exports = originalSymbol;
var helpers = require('./helperFunctions');

var originalScope = {
  define: function(state, n) {
    var scope = state['scope'];
    var t = this.def[n.value];
    if (typeof t === "object") {
      n.error(t.reserved ? "Already reserved." : "Already defined.");
    }
    this.def[n.value] = n;
    n.reserved = false;
    n.nud = helpers.itself;
    n.led = null;
    n.std = null;
    n.lbp = 0;
    n.scope = scope;
    return n;
  },
  delete: function(state, n) {
    delete this.def[n.value];
  },
  find: function(n, symbolTable) {
    var e = this,
      o;
    while (true) {
      o = e.def[n];
      if (o && typeof o !== 'function') {
        return e.def[n];
      }
      e = e.parent;
      if (!e) {
        o = symbolTable[n];
        return o && typeof o !== 'function' ? o : symbolTable["(name)"];
      }
    }
  },
  pop: function() {
    scope = this.parent;
  },
  reserve: function(n) {
    if (n.type !== "name" || n.reserved) {
      return;
    }
    var t = this.def[n.value];
    if (t) {
      if (t.reserved) {
        return;
      }
      if (t.type === "name") {
        n.error("Already defined.");
      }
    }
    this.def[n.value] = n;
    n.reserved = true;
  }
};

module.exports = originalScope;
var original_symbol = {
  nud: function() {
    this.error("Undefined.");
  },
  led: function(left) {
    this.error("Missing operator.");
  }
};

module.exports = original_symbol;
var util = require('util');
var diff = require('deep-diff').diff;
var helpers = require('./helperFunctions.js');
var advance = require('./advance');
var newScope = require('./newScope');
var originalScope = require('./originalScope');
var originalSymbol = require('./originalSymbol');
var symbol = require('./symbol');
var block = require('./block');
var expression = require('./expression');
var infix = require('./infix');
var infixr = require('./infixr');
var assignment = require('./assignment');
var declarations = require('./declarations');
var statements = require('./statements');
var rearrangeTokensDynamicDictionaryAssignment = require('./rearrangeTokensDynamicDictionaryAssignment');
var rearrangeTokensDictionaryKeyValueIteration = require('./rearrangeTokensDictionaryKeyValueIteration');
var rearrangeTokensPrintToConsoleLog = require('./rearrangeTokensPrintToConsoleLog');
var rearrangeTokensVariadicParams = require('./rearrangeTokensVariadicParams');
var rearrangeTokensAddParens = require('./rearrangeTokensAddParens');

var makeParser = function() {

  var state = {};
  state.scope;
  state.symbolTable = {};
  state.token;
  state.tokens;
  state.index = 0;

  declarations.symbols(state);
  declarations.assignments(state);
  declarations.infixes(state);
  declarations.prefixes(state);
  declarations.stmts(state);
  declarations.constants(state);

  var parseTokenStream = function(inputTokens) {
    var intermediaryTokenStream = helpers.cleanUpTokenStream(inputTokens);
    var intermediary = rearrangeTokensDynamicDictionaryAssignment(intermediaryTokenStream);
    var intermediary2 = rearrangeTokensPrintToConsoleLog(intermediary);
    var intermediary3 = rearrangeTokensDictionaryKeyValueIteration(intermediary2);
    var intermediary4 = rearrangeTokensVariadicParams(intermediary3);
    state.tokens = rearrangeTokensAddParens(intermediary4);
    state.scope = newScope(state, originalScope);

    /* Define globally accessible objects */
    /* console */
    var identifierSymbol = state.symbolTable["(name)"];
    var identifierToken = Object.create(identifierSymbol);
    identifierToken.type = "Identifier";
    identifierToken.value = "console";
    state.scope.define(state, identifierToken);

    /* Array */
    var identifierSymbol = state.symbolTable["(name)"];
    var identifierToken = Object.create(identifierSymbol);
    identifierToken.type = "Identifier";
    identifierToken.value = "Array";
    state.scope.define(state, identifierToken);

    /* arguments */
    var identifierSymbol = state.symbolTable["(name)"];
    var identifierToken = Object.create(identifierSymbol);
    identifierToken.type = "Identifier";
    identifierToken.value = "arguments";

    state.scope.define(state, identifierToken);

    state = advance(state);

    /* Remove leading new lines */
    while(true) {
      if(state.token.value === "\\n") {
        state = advance(state);
      }
      else {
        break;
      }
    }

    var s = statements(state);
    state = advance(state);
    state.scope.pop();

    var bodyNodes;
    if(s) {
      bodyNodes = Array.isArray(s) ? s : [s];
    } else {
      bodyNodes = [];
    }

    if(bodyNodes.length >= 1) {
      for(var q=0; q<bodyNodes.length; q++) {
        var n = bodyNodes[q];
        if(n.type === "CallExpression"){
          var expressionStmtWrapper = {
            type: "ExpressionStatement",
            expression: n
          }
          bodyNodes[q] = expressionStmtWrapper;
        }
      }
    }


    var result = {
      type: 'Program',
      sourceType: 'module',
      body: bodyNodes
    };

    /**
     * Walk result tree and remove properties that don't conform to Esprima standard.
     * * */
    helpers.traverse(result, function(currentNode) {
      helpers.deletePropertyIfExists(currentNode, ['reserved', 'nud', 'led', 'std', 'lbp', 'scope', 'assignment']);
    });

    return result;
  };

  return parseTokenStream;
};

module.exports = makeParser;
var util = require('util');
var diff = require('deep-diff').diff;
var helpers = require('./helperFunctions.js');
var makeParse = require('./parser');

var expected = {
  "type": "Program",
  "body": [
    {
      "type": "FunctionDeclaration",
      "id": {
        "type": "Identifier",
        "name": "returnWorld"
      },
      "params": [],
      "defaults": [],
      "body": {
        "type": "BlockStatement",
        "body": [
          {
            "type": "ReturnStatement",
            "argument": {
              "type": "Literal",
              "value": "World",
              "raw": "\"World\""
            }
          }
        ]
      },
      "generator": false,
      "expression": false
    },
    {
      "type": "FunctionDeclaration",
      "id": {
        "type": "Identifier",
        "name": "printInput"
      },
      "params": [
        {
          "type": "Identifier",
          "name": "input"
        }
      ],
      "defaults": [],
      "body": {
        "type": "BlockStatement",
        "body": [
          {
            "type": "ExpressionStatement",
            "expression": {
              "type": "CallExpression",
              "callee": {
                "type": "MemberExpression",
                "computed": false,
                "object": {
                  "type": "Identifier",
                  "name": "console"
                },
                "property": {
                  "type": "Identifier",
                  "name": "log"
                }
              },
              "arguments": [
                {
                  "type": "Identifier",
                  "name": "input"
                }
              ]
            }
          }
        ]
      },
      "generator": false,
      "expression": false
    },
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "CallExpression",
        "callee": {
          "type": "Identifier",
          "name": "printInput"
        },
        "arguments": [
          {
            "type": "BinaryExpression",
            "operator": "+",
            "left": {
              "type": "BinaryExpression",
              "operator": "+",
              "left": {
                "type": "Literal",
                "value": "Hello, ",
                "raw": "\"Hello, \""
              },
              "right": {
                "type": "CallExpression",
                "callee": {
                  "type": "Identifier",
                  "name": "returnWorld"
                },
                "arguments": []
              }
            },
            "right": {
              "type": "Literal",
              "value": "!",
              "raw": "\"!\""
            }
          }
        ]
      }
    }
  ],
  "sourceType": "module"
};
var tokenStream = [
  { type: 'DECLARATION_KEYWORD', value: 'func' },
  { type: 'IDENTIFIER', value: 'returnWorld' },
  { type: 'PARAMS_START', value: '(' },
  { type: 'PARAMS_END', value: ')' },
  { type: 'RETURN_ARROW', value: '->' },
  { type: 'TYPE_STRING', value: 'String' },
  { type: 'STATEMENTS_START', value: '{' },
  { type: 'TERMINATOR', value: '\\n' },

  { type: 'STATEMENT_KEYWORD', value: 'return' },
  { type: 'STRING', value: 'World' },
  { type: 'TERMINATOR', value: '\\n' },

  { type: 'STATEMENTS_END', value: '}' },
  { type: 'TERMINATOR', value: '\\n' },

  { type: 'DECLARATION_KEYWORD', value: 'func' },
  { type: 'IDENTIFIER', value: 'printInput' },
  { type: 'PARAMS_START', value: '(' },
  { type: 'IDENTIFIER', value: 'input' },
  { type: 'PUNCTUATION', value: ':' },
  { type: 'TYPE_STRING', value: 'String' },
  { type: 'PARAMS_END', value: ')' },
  { type: 'STATEMENTS_START', value: '{' },
  { type: 'TERMINATOR', value: '\\n' },

  { type: 'NATIVE_METHOD', value: 'print' },
  { type: 'INVOCATION_START', value: '(' },
  { type: 'IDENTIFIER', value: 'input' },
  { type: 'INVOCATION_END', value: ')' },
  { type: 'TERMINATOR', value: '\\n' },

  { type: 'STATEMENTS_END', value: '}' },
  { type: 'TERMINATOR', value: '\\n' },

  { type: 'IDENTIFIER', value: 'printInput' },
  { type: 'INVOCATION_START', value: '(' },
  { type: 'STRING', value: 'Hello, ' },
  { type: 'STRING_INTERPOLATION_START', value: '\\(' },
  { type: 'IDENTIFIER', value: 'returnWorld' },
  { type: 'INVOCATION_START', value: '(' },
  { type: 'INVOCATION_END', value: ')' },
  { type: 'STRING_INTERPOLATION_END', value: ')' },
  { type: 'STRING', value: '!' },
  { type: 'INVOCATION_END', value: ')' },
  { type: 'TERMINATOR', value: 'EOF' }
];
var parser = makeParse();

/**
 * First time
 */

var actual = parser(tokenStream);

console.log("############################");
console.log("############################");
console.log("##### BEGIN AST OUTPUT #####");
console.log(util.inspect(actual, {
  colors: true,
  depth: null
}));
console.log("############################");
console.log("############################");
console.log("############################");
console.log(util.inspect(expected, {
  colors: true,
  depth: null
}));
console.log("############################");
console.log("############################");
console.log("########## DIFF ############");
var dfrnc = diff(actual,expected);
console.log(dfrnc);

//var escodegen = require('escodegen');
//console.log('JSJSJSJSJSJSJSJSJSJSJSJSJSJSJS');
//console.log(escodegen.generate(expected));
//console.log('JSJSJSJSJSJSJSJSJSJSJSJSJSJSJS');
var symbol = require('./symbol');
var originalSymbol = require('./originalSymbol');
var expression = require('./expression');

var prefix = function(state, id, nud) {
  var s = symbol(state, originalSymbol, id);
  s.nud = nud || function() {
      state.scope.reserve(this);
      if (this.value === "++" || this.value === "--") {
        this.type = "UpdateExpression";
        this.operator = this.value;
        this.prefix = true;
        this.argument = expression(state, 70);
        delete this.value;
      } else if(this.value === "--") {
        this.type = "UpdateExpression";
        this.operator = "--";
        this.prefix = true;
        this.argument = expression(state, 70);
        delete this.value;
      } else if (this.value === "+") {
        this.type = "UnaryExpression";
        this.prefix = true;
        this.operator = "+";
      } else {
        this.type = "UnaryExpression";
        this.operator = this.value;
        delete this.value;
        this.argument = expression(state, 70);
        this.prefix = true;
      }

      return this;

    };
  return s;
};

module.exports = prefix;
var util = require('util');

var rearrangeTokensAddParens = function(tokens) {

  var reformat = false;
  var ifStatements = [];

  for(var i=0; i<tokens.length; i++) {
    if(tokens[i].value === "if" && tokens[i].type === "STATEMENT_KEYWORD") {
      reformat = true;
      var ifStatement = {
        ifIdx: i
      };
      var j = i;
      while (true) {
        j++;
        if (tokens[j].value === '{') {
          ifStatement.curlyIdx = j;
          break;
        }
      }
      ifStatements.push(ifStatement);
    }
  }

  if(reformat) {
    for(var m=ifStatements.length-1; m >= 0; m--) {
      var currentIfStmt = ifStatements[m];
      tokens.splice(currentIfStmt.ifIdx + 1, 0, { type: "PUNCTUATION",         value: "(" });
      tokens.splice(currentIfStmt.curlyIdx + 1, 0, { type: "PUNCTUATION",         value: ")" });
    }
  }

  //console.log(util.inspect(tokens, {colors:true, depth:null}));
  return tokens;
};

module.exports = rearrangeTokensAddParens;


var util = require('util');

var rearrangeTokensDictionaryKeyValueIteration = function(tokens) {

  var reformat = false;
  var identifierKey = 0;
  var identifierVal = 0;
  var identifierCol = 0;
  var insertAt = 0;
  var indicesOfTokensToRemove = [];
  var indexToAddVarKeyword = 0;
  var indexToAddEndParensToken = 0;

  for(var i=0; i<tokens.length; i++) {
    if(tokens[i].value === "for" && tokens[i].type === "STATEMENT_KEYWORD") {
      /* keyword:for is followed by #(; #var; #,; #var; #); #in; #var */
      if(tokens[i+1].type !== "PUNCTUATION" && tokens[i+1].value !== "(") continue;
      if(tokens[i+2].type !== "IDENTIFIER") continue;
      if(tokens[i+3].type !== "PUNCTUATION" && tokens[i+3].value !== ",") continue;
      if(tokens[i+4].type !== "IDENTIFIER") continue;
      if(tokens[i+5].type !== "PUNCTUATION" && tokens[i+5].value !== ")") continue;
      if(tokens[i+6].type !== "STATEMENT_KEYWORD") continue;
      if(tokens[i+7].type !== "IDENTIFIER") continue;
      if(tokens[i+8].type !== "PUNCTUATION" && tokens[i+8].value !== "{") continue;
      reformat = true;
      identifierKey = tokens[i+2].value;
      identifierVal = tokens[i+4].value;
      identifierCol = tokens[i+7].value;
      insertAt = i+9;
      indicesOfTokensToRemove.push(i+3);
      indicesOfTokensToRemove.push(i+4);
      indicesOfTokensToRemove.push(i+5);
      indexToAddVarKeyword = i+2;
      indexToAddEndParensToken = i+6;
    }
  }

  if(reformat) {

    tokens.splice(insertAt, 0,
      { type: "DECLARATION_KEYWORD", value: "var" },
      { type: "IDENTIFIER", value: identifierVal },
      { type: "OPERATOR", value: "=" },
      { type: "IDENTIFIER", value: identifierCol },
      { type: "SUBSCRIPT_LOOKUP_START", value: "[" },
      { type: "IDENTIFIER", value: identifierKey },
      { type: "SUBSCRIPT_LOOKUP_END", value: "]" },
      { type: "PUNCTUATION", value: ";" });
    tokens.splice(indicesOfTokensToRemove[0], indicesOfTokensToRemove.length);
    tokens.splice(indexToAddEndParensToken-3, 0,
      { type: 'PUNCTUATION', value: ')' });
    tokens.splice(indexToAddVarKeyword, 0,
      { type: "DECLARATION_KEYWORD", value: "var" });
  }

  //console.log(util.inspect(tokens, {colors:true, depth:null}));
  return tokens;
};

module.exports = rearrangeTokensDictionaryKeyValueIteration;
var util = require('util');

var rearrangeTokensDynamicDictionaryAssignment = function(tokensArray) {

  var start = 0;
  var end = 0;
  var identifierName;

  for(var i=0; i<tokensArray.length; i++) {
    var token = tokensArray[i];
    if(token.type === "DICTIONARY_START") {
      start = i;
      identifierName = tokensArray[i-2].value;
    }
    if(token.type === "DICTIONARY_END") {
      end = i;
    }
  }

  if(end === 0) {
    return tokensArray;
  }

  var dictionaryContents = tokensArray.slice(start+1, end);
  var kvDelim = [];
  for(var i=0; i<dictionaryContents.length; i++) {
    var token = dictionaryContents[i];
    if(token.value === ":" && token.type === "PUNCTUATION") {
      if(i === 0 && !dictionaryContents[i-1]) {
        return tokensArray;
      }
      if(dictionaryContents[i-1].type === "IDENTIFIER") {
        // the variable is the key
        kvDelim.push({ colonIdx: i, keyIdx: i-1 });
      } else if(dictionaryContents[i-1].value === "]" && dictionaryContents[i-3].value === "[" && dictionaryContents[i-4].type === "IDENTIFIER") {
        // property lookup is the key
        kvDelim.push({ colonIdx: i, keyIdx: i-4 });
      }
    }
  }

  if(kvDelim.length === 0) {
    return tokensArray;
  }

  for(var i=0; i<kvDelim.length; i++) {
    var obj = kvDelim[i];
    var idx = obj.keyIdx;
    if( ( idx - 1 ) >= 0) {
      if(dictionaryContents[idx-1]) {
        if(dictionaryContents[idx-1].value === ",") {
          //Swap comma token for semi-colon.
          dictionaryContents[idx-1].value = ";";
        }
      }
    }
  }

  for(var i=0; i<kvDelim.length; i++) {
    var obj = kvDelim[i];
    var idx = obj.colonIdx;
    if(dictionaryContents[idx]) {
      if(dictionaryContents[idx].value === ":") {
        //Swap colon for equal sign.
        dictionaryContents[idx].value = "=";
        dictionaryContents[idx].type = "OPERATOR";
      }
    }
  }

  var ranges = [];
  //split dictionaryContents
  for(var i=0; i<kvDelim.length; i++) {
    var kvpairObj = kvDelim[i];
    var kvStart = kvpairObj.keyIdx;
    var kvStop;
    if(kvDelim[i+1]) {
      kvStop = kvDelim[i+1].keyIdx - 1;
    } else {
      kvStop = null;
    }
    if(kvStop === null) {
      ranges.push({ start: kvStart });
    } else {
      ranges.push({ start: kvStart, stop: kvStop });
    }

  }

  var kvps = [];
  for(var i=0; i<ranges.length; i++) {
    var range = ranges[i];
    if(range.kvStop) {
      var kvp = dictionaryContents.slice(range.start);
    } else {
      var kvp = dictionaryContents.slice(range.start, range.stop);
    }
    kvps.push(kvp);
  }

  var statements = [];
  for(var i=0; i<kvDelim.length; i++) {
    var currentArray = [];
    currentArray.push({ type: "IDENTIFIER", value: identifierName });
    currentArray.push({ type: "PUNCTUATION", value: "[" });

    var sequence = kvps[i];
    var endKeyIndex = 0;
    for(var z=0; z<sequence.length; z++) {
      if(sequence[z].value === "=") {
        endKeyIndex = z;
        break;
      }
    }

    // insert key
    var keyArray = sequence.slice(0,endKeyIndex);
    for(var j=0; j<keyArray.length; j++) {
      currentArray.push(keyArray[j]);
    }
    currentArray.push({ type: "PUNCTUATION", value: "]" });

    // insert the rest
    var valArray = sequence.slice(endKeyIndex);
    for(var j=0; j<valArray.length; j++) {
      currentArray.push(valArray[j]);
    }

    statements.push(currentArray);
  }

  var throughDeclaration = tokensArray.slice(0, start+1);
  var dictEndThroughEnd = tokensArray.slice(end);

  var finalOutputArray = [];

  for(var i=0; i<throughDeclaration.length; i++) {
    finalOutputArray.push(throughDeclaration[i]);
  }
  for(var i=0; i<dictEndThroughEnd.length; i++) {
    if(i===0) {
      finalOutputArray.push(dictEndThroughEnd[i]);
    } else if(i===1) {
      finalOutputArray.push(dictEndThroughEnd[i]);
      for(var j=0; j<statements.length; j++) {
        var statement = statements[j];
        for(var k=0; k<statement.length; k++) {
          var item = statement[k];
          finalOutputArray.push(item);
          if(k === statement.length - 1) {
            finalOutputArray.push({ type: "PUNCTUATION", value: ";" });
          }
        }
      }
    } else {
      finalOutputArray.push(dictEndThroughEnd[i]);
    }
  }

  return finalOutputArray;
};

module.exports = rearrangeTokensDynamicDictionaryAssignment;
var util = require('util');

var rearrangeTokensPrintToConsoleLog = function(tokens) {

  var reformat = false;
  var nativePrintIndices = [];

  for(var i=0; i<tokens.length; i++) {
    if(tokens[i].value === "print" && tokens[i].type === "NATIVE_METHOD") {
      reformat = true;
      nativePrintIndices.push(i);
    }
  }

  if(reformat) {
    for(var j=nativePrintIndices.length - 1; j>=0; j--) {
      var index = nativePrintIndices[j];
      tokens.splice(index, 1,
        { type: "IDENTIFIER",         value: "console" },
        { type: "OPERATOR",           value: "." },
        { type: "IDENTIFIER",         value: "log" });
    }
  }

  //console.log(util.inspect(tokens, {colors:true, depth:null}));
  return tokens;
};

module.exports = rearrangeTokensPrintToConsoleLog;
var util = require('util');

var rearrangeTokensVariadicParams = function(tokens) {

  var reformat = false;
  var paramName = 0;
  var openBlock = 0;

  for(var i=0; i<tokens.length; i++) {
    if(tokens[i].value === "..." && tokens[i].type === "VARIADIC_PARAM") {
      reformat = true;
      var lookBack = i;
      while (true) {
        lookBack--;
        if (tokens[lookBack].value === ',' || tokens[lookBack].value === '(') {
          break;
        }
      }
      var lookAhead = i;
      while (true) {
        lookAhead++;
        if (tokens[lookAhead].value === ',' || tokens[lookAhead].value === ')') {
          break;
        }
      }
      openBlock = i;
      while(true) {
        openBlock++;
        if (tokens[openBlock].value === '{') {
          break;
        }
      }
      paramName = tokens[lookBack + 1].value;
      tokens.splice(lookBack + 1, (lookAhead - lookBack - 1));
    }
  }

  if(reformat) {
      tokens.splice(openBlock - 2, 0,
        //TODO insert var numbers = Array.prototype.slice.call(arguments[arguments.length-1]);
        { type: "DECLARATION_KEYWORD",  value: "var" },
        { type: "IDENTIFIER",           value: paramName },//Identifier
        { type: "OPERATOR",             value: "=" },
        { type: "IDENTIFIER",           value: "Array" },//Add to scope obj
        { type: "DOT_SYNTAX",           value: "." },
        { type: "IDENTIFIER",           value: "prototype" },//Add to scope obj
        { type: "DOT_SYNTAX",           value: "." },
        { type: "IDENTIFIER",           value: "slice" },
        { type: "DOT_SYNTAX",           value: "." },
        { type: "IDENTIFIER",           value: "call" },
        { type: "INVOCATION_START",     value: "(" },
        { type: "IDENTIFIER",           value: "arguments" },//Add to scope obj
        { type: "SUBSTRING_LOOKUP_START",value: "[" },
        { type: "IDENTIFIER",           value: "arguments" },
        { type: "DOT_SYNTAX",           value: "." },
        { type: "IDENTIFIER",           value: "length" },//Add to scope obj
        { type: "OPERATOR",             value: "-" },
        { type: "NUMBER",               value: "1" },
        { type: "SUBSTRING_LOOKUP_END", value: "]" },
        { type: "INVOCATION_END",       value: ")" },
        { type: "PUNCTUATION",          value: ";" },
        { type: "TERMINATOR",           value: "\\n" });
  }

  //console.log(util.inspect(tokens, {colors:true, depth:null}));
  return tokens;
};

module.exports = rearrangeTokensVariadicParams;

var advance = require('./advance');
var expression = require('./expression');

var statement = function(state) {

  while(true) {
    if(state.token.value === "\\n") {
      state = advance(state);
    }
    else {
      break;
    }
  }

  var n = state.token, v;

  if (n.std) {
    state = advance(state);
    state.scope.reserve(n);
    var statementResultNode = n.std();
    return statementResultNode;
  }


  if(state.token.value === ";") {
    state = advance(state);
  }
  while(true) {
    if(state.token.value === "\\n") {
      state = advance(state);
    }
    else {
      break;
    }
  }
  if(state.token.value === "}") {
    return v;
  }
  if(state.token.value === "EOF") {
    return v;
  }

  if(state.token.value === "->") {
    state = advance(state);
    state = advance(state);
  }

  v = expression(state, 0);

  if(state.token.value === ";") {
    state = advance(state);
  }
  while(true) {
    if(state.token.value === "\\n") {
      state = advance(state);
    } else {
      break;
    }
  }
  if(state.token.value === "}") {
    return v;
  }

  //while (true) {
  //  if (![';', '\\n', ')'].hasItem(state.token.value)) {
  //    state = advance(state);
  //  } else {
  //    break;
  //  }
  //}
  if (state.token.value === ')') {
    state = advance(state);
  }

  if(state.token.value === "EOF") {
    return v;
  } if(v.type === "FunctionDeclaration") {
    return v;
  } else if (!v.assignment && v.id !== "(" && state.token.value !== "console") {
    //console.log(state.token);
    //console.log(v);
    v.error("Bad expression statement.");
  }
  //state = advance(state, ";");
  //state = advance(state);

  return v;
};

module.exports = statement;
var statement = require('./statement');

var statements = function(state, optionalNumLoops, breakIfEndParen) {
  var a = [], s, count = 0;
  breakIfEndParen = breakIfEndParen || false;

  while (true) {
    if(count >= optionalNumLoops) {
      break;
    }
    if (state.token.id === ";") {
      a.push( { "type": "EmptyStatement" } );
      break;
    } else if (state.token.id === "}" || state.token.id === "(end)" || state.token.id === "EOF") {
      break;
    } else if (breakIfEndParen) {
      if (state.token.id === ')') {
        break;
      }
    }
    s = statement(state);
    if (s) {
      a.push(s);
      count++;
    }
  }
  return a.length === 0 ? null : a.length === 1 ? a[0] : a;
};

module.exports = statements;
var symbol = require('./symbol');
var originalSymbol = require('./originalSymbol');

var stmt = function(state, s, f) {
  var x = symbol(state, originalSymbol, s);
  x.std = f;
  return x;
};

module.exports = stmt;
var originalSymbol = require('./originalSymbol');

var symbol = function(state, originalSymbol, id, bp) {
  var s = state.symbolTable[id];
  bp = bp || 0;
  if (s) {
    if (bp >= s.lbp) {
      s.lbp = bp;
    }
  } else {
    s = Object.create(originalSymbol);
    s.id = s.value = id;
    s.lbp = bp;
    state.symbolTable[id] = s;
  }
  return s;
};

module.exports = symbol;
Array.prototype.hasItem = function(val) {
  return this.indexOf(val) > -1;
};

module.exports = {
  terminator : [
    "ARRAY_END",
    "DICTIONARY_END",
    "TUPLE_END",
    "TERMINATOR"
  ],
  primitive : [
    "NUMBER",
    "BOOLEAN",
    "STRING"
  ],
  collectionStart : [
    "ARRAY_START",
    "DICTIONARY_START",
    "TUPLE_START"
  ],
  verb : [
    "PARAMS_START",
    "PARAMS_END",
    "STATEMENTS_START",
    "STATEMENTS_END",
    "INVOCATION_START",
    "INVOCATION_END",
    "PUNCTUATION",
    "OPERATOR",
    "SUBSTRING_LOOKUP_END",
    "SUBSTRING_LOOKUP_START",
    "SUBSCRIPT_LOOKUP_START",
    "SUBSCRIPT_LOOKUP_END",
    "DOT_SYNTAX"

  ],
  noun : [
    "DECLARATION_KEYWORD",
    "IDENTIFIER",
    "TUPLE_ELEMENT_NAME",
    "STATEMENT_KEYWORD",
    "TYPE_BOOLEAN",
    "TYPE_NUMBER",
    "TYPE_STRING",
    "RETURN_ARROW",
    "VARIADIC_PARAM"
  ],
  comment : [
    "COMMENT_START",
    "COMMENT",
    "MULTI_LINE_COMMENT_START",
    "MULTI_LINE_COMMENT_END"
  ]
};



Array.prototype.hasItem = function(val) {
  return this.indexOf(val) > -1;
};

module.exports = {
  terminator : ["ARRAY_END", "DICTIONARY_END", "TUPLE_END", "TERMINATOR"],
  primitive : ["NUMBER", "BOOLEAN", "STRING"],
  collectionStart : ["ARRAY_START", "DICTIONARY_START", "TUPLE_START"],
  verb : ["PUNCTUATION", "OPERATOR", "SUBSTRING_LOOKUP_END", "SUBSTRING_LOOKUP_START"],
  noun : ["DECLARATION_KEYWORD", "IDENTIFIER", "TUPLE_ELEMENT_NAME", "STATEMENT_KEYWORD"]
};